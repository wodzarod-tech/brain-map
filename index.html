<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Graph Editor ‚Äî Custom Nodes</title>
<style>
  :root{
    --toolbar-bg:#fff;
    --toolbar-shadow: 0 4px 14px rgba(10,10,10,0.08);
    --accent: #3498db;
    --muted: #666;
    --node-radius: 25;
  }
  html,body{height:100%;margin:0;font-family:Inter,Arial,system-ui,-apple-system,Segoe UI,Roboto; background:#f7f8fb; color:#111}
  /* Toolbar centered bottom */
  #toolbar{
    position:fixed;
    left:50%;
    transform:translateX(-50%);
    bottom:12px;
    display:flex;
    gap:8px;
    align-items:center;
    background:var(--toolbar-bg);
    padding:8px 10px;
    border-radius:10px;
    box-shadow:var(--toolbar-shadow);
    z-index:60;
  }
  #toolbar button, #toolbar select { background:transparent; border:0; padding:6px 8px; cursor:pointer; border-radius:6px; font-size:14px }
  #toolbar button:hover { background:#f0f4ff }
  #toolbar .icon { font-size:14px; margin-right:6px }
  
  /* Canvas */
  canvas#canvas{position:fixed;left:0;top:0}
  #exportCommentsBtn{position:fixed;right:10px;top:10px;z-index:55;display:none}
  
  /* context menu */
  #nodeMenu{
    position:fixed;
    display:none;
    background:#fff;
    border:1px solid #ddd;
    padding:8px;
    border-radius:8px;
    min-width:220px;
    z-index:120;
    box-shadow:0 6px 18px rgba(10,10,10,0.08);
  }
  #nodeMenu .row{display:flex;gap:8px;align-items:center;margin-top:6px}
  #nodeMenu .row label{font-size:13px;color:var(--muted);width:60px}
  #nodeMenu button.small{padding:6px 8px;font-size:13px}
  #nodeMenu button#menuClose{position:absolute;right:8px;top:6px;border:0;background:transparent;cursor:pointer}
  /* comment modal */
  #commentModal{display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#fff;border:1px solid #ddd;padding:14px;border-radius:8px;z-index:200;box-shadow:0 20px 50px rgba(10,10,10,0.12);width:360px;max-width:95%}
  #commentEditor{width:100%;height:140px;border:1px solid #eee;padding:8px;border-radius:6px;overflow:auto;background:#fafafa}
  /* tooltip */
  .tooltip{position:fixed;padding:6px 10px;background:#222;color:#fff;border-radius:6px;pointer-events:none;z-index:150;display:none;max-width:320px;white-space:pre-wrap}
  /* utilities */
  .hidden{display:none}
</style>
</head>
<body>

  <!-- Toolbar -->
  <div id="toolbar" aria-label="Graph toolbar">
    <button id="drawSquareBtn" title="Draw square (grid snapped)"><span class="icon">‚¨õ</span>Square</button>
    <button id="undoBtn" title="Undo">‚Ü©Ô∏è</button>
    <button id="redoBtn" title="Redo">‚Ü™Ô∏è</button>
    <button id="loadGraphBtn" title="Load JSON">üìÇ</button>
    <button id="saveAllBtn" title="Save JSON">üíæ</button>
    <button id="exportPngBtn" title="Export PNG">üì§</button>
    <input id="loadGraphInput" accept=".json" type="file" class="hidden">
  </div>

  <canvas id="canvas"></canvas>
  <button id="exportCommentsBtn">Export Comments JSON</button>

  <!-- Node context menu -->
  <div id="nodeMenu" role="menu" aria-hidden="true">
    <button id="menuClose" aria-label="Close menu">‚úï</button>
    <div class="row">
      <label for="menuColor">Color</label>
      <input id="menuColor" type="color" value="#3498db">
      <select id="menuShape" title="Shape">
        <option value="circle">Circle</option>
        <option value="square">Square</option>
        <option value="rounded">Rounded</option>
      </select>
      <button id="menuDelete" class="small" title="Delete node">üóëÔ∏è</button>
    </div>

    <div class="row">
      <label>Arrow</label>
      <select id="menuEdgeType" title="Edge type">
        <option value="solid">Solid</option>
        <option value="dashed">Dashed</option>
        <option value="bold">Bold</option>
      </select>

      <select id="menuArrowhead" title="Arrowhead">
        <option value="triangle">Triangle</option>
        <option value="diamond">Diamond</option>
        <option value="none">None</option>
      </select>
    </div>

    <div class="row">
      <label>Title</label>
      <button id="menuAddTitle" class="small">Add / Edit</button>
      <select id="menuTitlePos" title="Title pos">
        <option value="above">Above</option>
        <option value="inside">Inside</option>
        <option value="below">Below</option>
      </select>
      <button id="menuSeeComments" class="small" title="Notes">üìù</button>
    </div>
  </div>

  <!-- Comment Modal -->
  <div id="commentModal" aria-hidden="true">
    <div style="font-weight:700;margin-bottom:8px">Edit Comment</div>
    <div id="commentEditor" contenteditable="true" aria-label="Comment editor"></div>
    <div style="text-align:right;margin-top:8px">
      <button id="commentCancel">Cancel</button>
      <button id="commentSave">Save</button>
    </div>
  </div>

  <!-- Tooltip -->
  <div id="tooltip" class="tooltip"></div>

<script>
/* -------------------------
   Helper & Utility Functions
   ------------------------- */
const $ = id => document.getElementById(id);
const deepClone = v => JSON.parse(JSON.stringify(v));
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const devicePixelRatioSafe = () => window.devicePixelRatio || 1;

function saveHistory(){
  history.push({ nodes: JSON.parse(JSON.stringify(nodes)), edges: JSON.parse(JSON.stringify(edges)) });
  if(history.length > 200) history.shift();
  redoStack = [];
}

/* -------------------------
   DOM refs
   ------------------------- */
const canvas = $('canvas');
const ctx = canvas.getContext('2d');

const drawSquareBtn = $('drawSquareBtn');
const undoBtn = $('undoBtn');
const redoBtn = $('redoBtn');
const loadGraphBtn = $('loadGraphBtn');
const loadGraphInput = $('loadGraphInput');
const saveAllBtn = $('saveAllBtn');
const exportPngBtn = $('exportPngBtn');
const exportCommentsBtn = $('exportCommentsBtn');

const nodeMenu = $('nodeMenu');
const menuColor = $('menuColor');
const menuShape = $('menuShape');
const menuEdgeType = $('menuEdgeType');
const menuArrowhead = $('menuArrowhead');
const menuDelete = $('menuDelete');
const menuAddTitle = $('menuAddTitle');
const menuTitlePos = $('menuTitlePos');
const menuSeeComments = $('menuSeeComments');
const menuClose = $('menuClose');

const commentModal = $('commentModal');
const commentEditor = $('commentEditor');
const commentCancel = $('commentCancel');
const commentSave = $('commentSave');

const tooltip = $('tooltip');

/* -------------------------
   State
   ------------------------- */
let nodes = []; // {x,y,color,shape,title,titlePos,comment,selectedEdgeType,selectedArrowhead}
let edges = []; // {from,to,type,arrowhead}
let history = [];
let redoStack = [];
const HISTORY_LIMIT = 200;

let connecting = false;
let sourceNode = null;
let draggingNode = null;
let dragOffset = {x:0,y:0};
let justDragged = false;

let scale = 1;
let offsetX = 0;
let offsetY = 0;
let isPanning = false;
let panStart = {x:0,y:0};

let menuNodeRef = null;
let menuNodeIndex = -1;
let editingNode = null;

// Edge selection/menu refs
let menuEdgeRef = null;
let menuEdgeIndex = -1;
let selectedEdgeIndex = -1;

/* -------------------------
   Canvas resize & DPR
   ------------------------- */
function resizeCanvas(){
  const dpr = devicePixelRatioSafe();
  canvas.width = Math.round(window.innerWidth * dpr);
  canvas.height = Math.round(window.innerHeight * dpr);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* -------------------------
   Coordinate transforms
   ------------------------- */
function screenToWorld(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const cx = clientX - rect.left;
  const cy = clientY - rect.top;
  return { x: (cx - offsetX) / scale, y: (cy - offsetY) / scale };
}
function worldToScreen(wx, wy){
  return { x: wx * scale + offsetX, y: wy * scale + offsetY };
}

/* -------------------------
   History (undo/redo)
   ------------------------- */
function pushHistory(){
  history.push({ nodes: deepClone(nodes), edges: deepClone(edges) });
  if(history.length > HISTORY_LIMIT) history.shift();
  redoStack = [];
}

function undo(){
  if(history.length === 0) return;
  redoStack.push({ nodes: deepClone(nodes), edges: deepClone(edges) });
  const prev = history.pop();
  nodes = prev.nodes;
  edges = prev.edges;
}
function redo(){
  if(redoStack.length === 0) return;
  history.push({ nodes: deepClone(nodes), edges: deepClone(edges) });
  const next = redoStack.pop();
  nodes = next.nodes;
  edges = next.edges;
}

/* -------------------------
   Drawing helpers
   ------------------------- */
function drawGrid(ctxLocal, width, height, gridSize = 50){
  ctxLocal.save();
  ctxLocal.strokeStyle = '#eef1f7';
  ctxLocal.lineWidth = 1;
  ctxLocal.beginPath();
  // compute start positions relative to offset & scale
  const startX = -offsetX % (gridSize * scale);
  const startY = -offsetY % (gridSize * scale);
  for(let x = startX; x < width; x += gridSize * scale){
    ctxLocal.moveTo(Math.round(x)+0.5, 0);
    ctxLocal.lineTo(Math.round(x)+0.5, height);
  }
  for(let y = startY; y < height; y += gridSize * scale){
    ctxLocal.moveTo(0, Math.round(y)+0.5);
    ctxLocal.lineTo(width, Math.round(y)+0.5);
  }
  ctxLocal.stroke();
  ctxLocal.restore();
}

function drawNodeOnCtx(ctxLocal, n){
  const r = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--node-radius')) || 25;
  ctxLocal.fillStyle = n.color || '#3498db';
  ctxLocal.strokeStyle = '#333';
  ctxLocal.lineWidth = 2 / Math.max(0.4, scale);

  if(n.shape === 'circle'){
    ctxLocal.beginPath();
    ctxLocal.arc(n.x, n.y, r, 0, Math.PI*2);
    ctxLocal.fill();
    ctxLocal.stroke();
  } else if(n.shape === 'square'){
    ctxLocal.beginPath();
    ctxLocal.rect(n.x-r, n.y-r, r*2, r*2);
    ctxLocal.fill();
    ctxLocal.stroke();
  } else { // rounded
    const rx = r*2, ry = r*2, rad = 10;
    const x = n.x - rx/2, y = n.y - ry/2;
    ctxLocal.beginPath();
    ctxLocal.moveTo(x + rad, y);
    ctxLocal.lineTo(x + rx - rad, y);
    ctxLocal.quadraticCurveTo(x + rx, y, x + rx, y + rad);
    ctxLocal.lineTo(x + rx, y + ry - rad);
    ctxLocal.quadraticCurveTo(x + rx, y + ry, x + rx - rad, y + ry);
    ctxLocal.lineTo(x + rad, y + ry);
    ctxLocal.quadraticCurveTo(x, y + ry, x, y + ry - rad);
    ctxLocal.lineTo(x, y + rad);
    ctxLocal.quadraticCurveTo(x, y, x + rad, y);
    ctxLocal.fill();
    ctxLocal.stroke();
  }

  // title
  if(n.title){
    const fontSize = Math.max(12, 14 / Math.max(0.5, scale));
    ctxLocal.font = `${fontSize}px sans-serif`;
    ctxLocal.fillStyle = '#000';
    ctxLocal.textAlign = 'center';
    ctxLocal.textBaseline = 'middle';
    let ty = n.y;
    if(n.titlePos === 'above') ty = n.y - r - 10;
    else if(n.titlePos === 'below') ty = n.y + r + 10;
    ctxLocal.fillText(n.title, n.x, ty);
  }
}

function drawArrowhead(ctxLocal, tipX, tipY, ang, type = 'triangle'){
  ctxLocal.save();
  ctxLocal.fillStyle = '#000';
  const size = 12 / Math.max(1, scale); // size scales visually
  ctxLocal.beginPath();
  if(type === 'triangle'){
    const leftX = tipX - size * Math.cos(ang - Math.PI / 6);
    const leftY = tipY - size * Math.sin(ang - Math.PI / 6);
    const rightX = tipX - size * Math.cos(ang + Math.PI / 6);
    const rightY = tipY - size * Math.sin(ang + Math.PI / 6);
    ctxLocal.moveTo(tipX, tipY);
    ctxLocal.lineTo(leftX, leftY);
    ctxLocal.lineTo(rightX, rightY);
    ctxLocal.closePath();
    ctxLocal.fill();
  } else if(type === 'diamond'){
    const backX = tipX - size * Math.cos(ang);
    const backY = tipY - size * Math.sin(ang);
    const leftX = backX - (size / 2) * Math.sin(ang);
    const leftY = backY + (size / 2) * Math.cos(ang);
    const rightX = backX + (size / 2) * Math.sin(ang);
    const rightY = backY - (size / 2) * Math.cos(ang);
    ctxLocal.moveTo(tipX, tipY);
    ctxLocal.lineTo(leftX, leftY);
    ctxLocal.lineTo(backX, backY);
    ctxLocal.lineTo(rightX, rightY);
    ctxLocal.closePath();
    ctxLocal.fill();
  }
  ctxLocal.restore();
}

function drawEdgesOnCtx(ctxLocal){
  const nodeR = 25;
  for (let i = 0; i < edges.length; i++) {
    const e = edges[i];
    const a = nodes[e.from], b = nodes[e.to];
    if(!a || !b) continue;
    ctxLocal.save();

    // highlight selected edge
    if (i === selectedEdgeIndex) {
      ctxLocal.strokeStyle = 'red';
      ctxLocal.lineWidth = 6 / Math.max(0.4, scale);
      ctxLocal.setLineDash([]);
    } else {
      ctxLocal.lineWidth = (e.type === 'bold' ? 4 : 2) / Math.max(0.4, scale);
      if(e.type === 'dashed') ctxLocal.setLineDash([10/scale, 8/scale]);
      else ctxLocal.setLineDash([]);
      ctxLocal.strokeStyle = '#000';
    }

    const ang = Math.atan2(b.y - a.y, b.x - a.x);
    // shorten line so arrow tip sits at node border
    const tipX = b.x - nodeR * Math.cos(ang);
    const tipY = b.y - nodeR * Math.sin(ang);

    // start from node border as well
    const startX = a.x + nodeR * Math.cos(ang);
    const startY = a.y + nodeR * Math.sin(ang);

    ctxLocal.beginPath();
    ctxLocal.moveTo(startX, startY);
    ctxLocal.lineTo(tipX, tipY);
    ctxLocal.stroke();

    if(e.arrowhead && e.arrowhead !== 'none'){
      drawArrowhead(ctxLocal, tipX, tipY, ang, e.arrowhead);
    }

    ctxLocal.restore();
  }
}

/* -------------------------
   Hit test for edges
   ------------------------- */
function findEdgeAt(p) {
  const threshold = 10 / Math.max(0.5, scale);

  for (let i = edges.length - 1; i >= 0; i--) {
    const e = edges[i];
    const a = nodes[e.from];
    const b = nodes[e.to];
    if (!a || !b) continue;

    const A = { x: a.x, y: a.y };
    const B = { x: b.x, y: b.y };
    const P = p;

    const AB = { x: B.x - A.x, y: B.y - A.y };
    const AP = { x: P.x - A.x, y: P.y - A.y };
    const ab2 = AB.x * AB.x + AB.y * AB.y;
    if (ab2 === 0) continue;

    let t = (AP.x * AB.x + AP.y * AB.y) / ab2;
    t = Math.max(0, Math.min(1, t));
    const closest = { x: A.x + AB.x * t, y: A.y + AB.y * t };

    if (Math.hypot(P.x - closest.x, P.y - closest.y) < threshold) {
      return { edge: e, index: i };
    }
  }
  return null;
}

/* -------------------------
   Main render loop
   ------------------------- */
let lastRenderTime = 0;
function renderLoop(time){
  // throttle render if needed
  const dpr = devicePixelRatioSafe();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw grid on screen-space to align with pixels
  drawGrid(ctx, canvas.width / dpr, canvas.height / dpr, 50);

  ctx.save();
  // world transform (scale then translate)
  ctx.setTransform(scale * dpr, 0, 0, scale * dpr, offsetX * dpr, offsetY * dpr);

  // highlight source node if connecting
  if(sourceNode){
    ctx.save();
    ctx.beginPath();
    ctx.arc(sourceNode.x, sourceNode.y, 35, 0, Math.PI * 2);
    ctx.strokeStyle = 'orange';
    ctx.lineWidth = 4 / Math.max(0.5, scale);
    ctx.stroke();
    ctx.restore();
  }

  drawEdgesOnCtx(ctx);
  for(const n of nodes) drawNodeOnCtx(ctx, n);

  ctx.restore();

  // request next frame
  requestAnimationFrame(renderLoop);
}
requestAnimationFrame(renderLoop);

/* -------------------------
   Interaction: create, select, connect, pan, drag
   ------------------------- */
function findNodeAt(worldP, radius = 30){
  for(let i = nodes.length - 1; i >= 0; i--){
    const n = nodes[i];
    if(Math.hypot(worldP.x - n.x, worldP.y - n.y) < radius) return { node: n, index: i };
  }
  return null;
}

canvas.addEventListener('click', (ev) => {
  // single click: create node if not clicked on node; or handle connect logic
  if(draggingNode) return;
  if(justDragged){ justDragged = false; return; }

  const p = screenToWorld(ev.clientX, ev.clientY);
  const hit = findNodeAt(p);

  // 1. NODE CLICK ?
  if(hit){
    // clicking node clears edge selection
    selectedEdgeIndex = -1;
    menuEdgeRef = null;
    menuEdgeIndex = -1;

    const clicked = hit.node;
    const clickedIndex = hit.index;
    if(!sourceNode){
      // mark source for connecting
      sourceNode = clicked;
      sourceNode._origColor = sourceNode._origColor || sourceNode.color;
      sourceNode.color = '#ffeb3b';
      return;
    }
    // if clicking same node, deselect
    if(sourceNode === clicked){
      sourceNode.color = sourceNode._origColor || sourceNode.color;
      delete sourceNode._origColor;
      sourceNode = null;
      return;
    }
    // create edge from sourceNode to clicked (store indices)
    pushHistory();
    edges.push({
      from: nodes.indexOf(sourceNode),
      to: clickedIndex,
      type: sourceNode.selectedEdgeType || menuEdgeType.value || 'solid',
      arrowhead: sourceNode.selectedArrowhead || menuArrowhead.value || 'triangle'
    });
    // restore color & clear source
    if(sourceNode){ sourceNode.color = sourceNode._origColor || sourceNode.color; delete sourceNode._origColor; }
    sourceNode = null;
    return;
  }

  // 2. EDGE CLICK ?
  const edgeHit = findEdgeAt(p);
  if(edgeHit){
    // clear node selection
    if (sourceNode) {
      sourceNode.color = sourceNode._origColor || sourceNode.color;
      delete sourceNode._origColor;
      sourceNode = null;
    }

    selectedEdgeIndex = edgeHit.index;
    //showEdgeMenu(ev.clientX, ev.clientY, edgeHit.edge, edgeHit.index);
    return;
  }

  // 3. EMPTY CLICK -> create node or clear selections
  // clear selections
  selectedEdgeIndex = -1;
  menuEdgeRef = null;
  menuEdgeIndex = -1;
  // also clear node-source selection if any
  if (sourceNode) {
    sourceNode.color = sourceNode._origColor || sourceNode.color;
    delete sourceNode._origColor;
    sourceNode = null;
  }
  hideMenu();

  if(connecting) { /* ignore create while in global connect toggle */ return; }
  pushHistory();
  const grid = 50;
  const nx = Math.round(p.x / grid) * grid;
  const ny = Math.round(p.y / grid) * grid;
  nodes.push({
    x: nx, y: ny,
    color: '#3498db',
    shape: 'circle',
    title: '',
    titlePos: 'above',
    comment: '',
    selectedEdgeType: 'solid',
    selectedArrowhead: 'triangle'
  });
});

/* mousedown: start dragging node (left), or start panning (middle/right) */
canvas.addEventListener('mousedown', (ev) => {
  const p = screenToWorld(ev.clientX, ev.clientY);
  if(ev.button === 0){
    // left button: try pick node
    const hit = findNodeAt(p);
    if(hit){
      draggingNode = hit.node;
      dragOffset.x = p.x - draggingNode.x;
      dragOffset.y = p.y - draggingNode.y;
      return;
    }
  }
  // middle or right: pan
  if(ev.button === 1 || ev.button === 2){
    isPanning = true;
    panStart.x = ev.clientX - offsetX;
    panStart.y = ev.clientY - offsetY;
    if(ev.button === 2) ev.preventDefault();
  }
});

/* mousemove: dragging or panning; show tooltip for comments */
canvas.addEventListener('mousemove', (ev) => {
  const p = screenToWorld(ev.clientX, ev.clientY);
  if(draggingNode){
    const newX = p.x - dragOffset.x;
    const newY = p.y - dragOffset.y;
    if(Math.hypot(newX - draggingNode.x, newY - draggingNode.y) > 2) justDragged = true;
    draggingNode.x = newX;
    draggingNode.y = newY;
    return;
  }
  if(isPanning){
    offsetX = ev.clientX - panStart.x;
    offsetY = ev.clientY - panStart.y;
    return;
  }

  // tooltip for comments
  const hit = findNodeAt(p);
  if(hit && hit.node.comment){
    tooltip.style.left = (ev.clientX + 12) + 'px';
    tooltip.style.top = (ev.clientY + 12) + 'px';
    tooltip.innerText = hit.node.comment;
    tooltip.style.display = 'block';
  } else {
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('mouseup', (ev) => {
  if(draggingNode){
    // snap to grid on drop
    const grid = 50;
    draggingNode.x = Math.round(draggingNode.x / grid) * grid;
    draggingNode.y = Math.round(draggingNode.y / grid) * grid;
    pushHistory();
  }
  draggingNode = null;
  isPanning = false;
  if(justDragged){
    setTimeout(()=> justDragged = false, 40);
  }
});

canvas.addEventListener('mouseleave', () => {
  tooltip.style.display = 'none';
  draggingNode = null;
  isPanning = false;
});

/* context menu (right click) - open node menu or delete edge if clicked on edge */
canvas.addEventListener('contextmenu', (ev) => {
  ev.preventDefault();
  const p = screenToWorld(ev.clientX, ev.clientY);

  // 1Ô∏è‚É£ NODE FIRST ‚Äî ALWAYS
  const nodeHit = findNodeAt(p);
  if (nodeHit) {
    showMenuForNode(nodeHit.node, ev.clientX, ev.clientY, nodeHit.index);
    return; // IMPORTANT
  }

  // 2Ô∏è‚É£ EDGE SECOND ‚Äî ONLY IF NO NODE HIT
  const edgeHit = findEdgeAt(p);
  if (edgeHit) {
    showEdgeMenu(ev.clientX, ev.clientY, edgeHit.edge, edgeHit.index);
    return;
  }

  hideMenu();
});

canvas.addEventListener('dblclick', (e) => {
  if (e.button !== 0) return; // left button only
  const p = screenToWorld(e.clientX, e.clientY);

  // 1) Check edges first ‚Äî delete vas.addEventListeneredge on double-click
  const edgeHit = findEdgeAt(p);
  const nodeHit = findNodeAt(p);

  if (edgeHit && !nodeHit) {
    pushHistory();
    edges.splice(edgeHit.index, 1);
    // clear any UI state related to edge selection/menu if you have it:
    selectedEdge = null;
    hideMenu();
    return;
  }
  
  if(nodeHit){
	  // 2) If no edge, check nodes (existing behaviour)
	  for (let i = nodes.length - 1; i >= 0; i--) {
		const n = nodes[i];
		if (Math.hypot(p.x - n.x, p.y - n.y) < 30) {
		  // Delete node
		  pushHistory();
		  
		  // Remove connected edges
		  for (let j = edges.length - 1; j >= 0; j--) {
			if (edges[j].from === i || edges[j].to === i) edges.splice(j, 1);
		  }
		  nodes.splice(i, 1);
		  nodeMenu.style.display = 'none';
		  menuNodeRef = null;
		  menuNodeIndex = -1;
		  break;
		}
	  }
  }
});

/* -------------------------
   Node Menu actions
   ------------------------- */
function showMenuForNode(node, clientX, clientY, index){
  menuColor.value = node.color || '#3498db';
  menuShape.value = node.shape || 'circle';
  menuTitlePos.value = node.titlePos || 'above';
  menuEdgeType.value = node.selectedEdgeType || 'solid';
  menuArrowhead.value = node.selectedArrowhead || 'triangle';

  // clear edge refs when showing node menu
  menuEdgeRef = null;
  menuEdgeIndex = -1;
  selectedEdgeIndex = -1;

  menuNodeRef = node;
  menuNodeIndex = index;
  nodeMenu.style.left = clientX + 'px';
  nodeMenu.style.top = clientY + 'px';
  nodeMenu.style.display = 'block';
  nodeMenu.setAttribute('aria-hidden', 'false');

  // enable node controls
  menuColor.disabled = false;
  menuShape.disabled = false;
  menuAddTitle.disabled = false;
  menuTitlePos.disabled = false;
  menuSeeComments.disabled = false;
}

function hideMenu(){
  nodeMenu.style.display = 'none';
  nodeMenu.setAttribute('aria-hidden', 'true');
  menuNodeRef = null;
  menuNodeIndex = -1;
  menuEdgeRef = null;
  menuEdgeIndex = -1;
}

menuClose.addEventListener('click', hideMenu);

// delete node via menu (now handles edges too)
menuDelete.addEventListener('click', () => {
  if(menuEdgeRef && menuEdgeIndex >= 0){
    pushHistory();
    edges.splice(menuEdgeIndex, 1);
    hideMenu();
    return;
  }

  if(menuNodeRef && menuNodeIndex >= 0){
    pushHistory();
    // remove edges linking to this node
    for(let j = edges.length - 1; j >= 0; j--){
      if(edges[j].from === menuNodeIndex || edges[j].to === menuNodeIndex) edges.splice(j,1);
    }
    nodes.splice(menuNodeIndex, 1);
    hideMenu();
    return;
  }
});

// color change
menuColor.addEventListener('input', () => {
  if(!menuNodeRef) return;
  pushHistory();
  menuNodeRef.color = menuColor.value;
});

// shape change
menuShape.addEventListener('change', () => {
  if(!menuNodeRef) return;
  pushHistory();
  menuNodeRef.shape = menuShape.value;
});

// edge type & arrow selection are stored either on node (when preparing connections) or on selected edge
menuEdgeType.addEventListener('change', () => {
  if(menuNodeRef){
    menuNodeRef.selectedEdgeType = menuEdgeType.value;
    return;
  }
  if(menuEdgeRef){
    pushHistory();
    menuEdgeRef.type = menuEdgeType.value;
  }
});
menuArrowhead.addEventListener('change', () => {
  if(menuNodeRef){
    menuNodeRef.selectedArrowhead = menuArrowhead.value;
    return;
  }
  if(menuEdgeRef){
    pushHistory();
    menuEdgeRef.arrowhead = menuArrowhead.value;
  }
});

// add title
menuAddTitle.addEventListener('click', () => {
  if(!menuNodeRef) return;
  const t = prompt('Enter title', menuNodeRef.title || '');
  pushHistory();
  menuNodeRef.title = t || '';
  menuNodeRef.titlePos = menuTitlePos.value || 'above';
  hideMenu();
});

// comments: open modal
menuSeeComments.addEventListener('click', () => {
  if(!menuNodeRef) return;
  editingNode = menuNodeRef;
  commentEditor.innerText = menuNodeRef.comment || '';
  commentModal.style.display = 'block';
  hideMenu();
});

/* comment modal actions */
commentCancel.addEventListener('click', ()=>{ commentModal.style.display = 'none'; editingNode = null; });
commentSave.addEventListener('click', () => {
  if(!editingNode) return;
  pushHistory();
  editingNode.comment = commentEditor.innerText || '';
  commentModal.style.display = 'none';
  editingNode = null;
});

/* close menu on outside click */
document.addEventListener('mousedown', (ev) => {
  if(nodeMenu.style.display === 'block'){
    const rect = nodeMenu.getBoundingClientRect();
    if(!(ev.clientX >= rect.left && ev.clientX <= rect.right && ev.clientY >= rect.top && ev.clientY <= rect.bottom)){
      hideMenu();
    }
  }
});

/* -------------------------
   Edge Menu actions (showing menu for edge)
   ------------------------- */
function showEdgeMenu(clientX, clientY, edge, index){
  // clear node refs
  menuNodeRef = null;
  menuNodeIndex = -1;

  // set edge refs
  menuEdgeRef = edge;
  menuEdgeIndex = index;
  selectedEdgeIndex = index;

  // position & show menu
  nodeMenu.style.left = clientX + 'px';
  nodeMenu.style.top = clientY + 'px';
  nodeMenu.style.display = 'block';
  nodeMenu.setAttribute('aria-hidden', 'false');

  // preload edge values
  menuEdgeType.value = edge.type || 'solid';
  menuArrowhead.value = edge.arrowhead || 'triangle';

  // disable node-only controls
  menuColor.disabled = true;
  menuShape.disabled = true;
  menuAddTitle.disabled = true;
  menuTitlePos.disabled = true;
  menuSeeComments.disabled = true;
}

/* -------------------------
   Export / Import / Save
   ------------------------- */
saveAllBtn.addEventListener('click', () => {
  const data = { nodes: nodes.map(n => ({
    x:n.x,y:n.y,color:n.color,shape:n.shape,title:n.title,titlePos:n.titlePos,comment:n.comment,selectedEdgeType:n.selectedEdgeType,selectedArrowhead:n.selectedArrowhead
  })), edges: edges.map(e => ({ from:e.from, to:e.to, type:e.type, arrowhead:e.arrowhead })) };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'graph_data.json';
  a.click();
});

loadGraphBtn.addEventListener('click', () => loadGraphInput.click());
loadGraphInput.addEventListener('change', (ev) => {
  const file = ev.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try{
      const data = JSON.parse(e.target.result);
      if(!data.nodes || !data.edges) throw new Error('Invalid format');
      pushHistory();
      nodes = data.nodes.map(n => ({
        x: n.x, y: n.y,
        color: n.color || '#3498db',
        shape: n.shape || 'circle',
        title: n.title || '',
        titlePos: n.titlePos || 'above',
        comment: n.comment || '',
        selectedEdgeType: n.selectedEdgeType || 'solid',
        selectedArrowhead: n.selectedArrowhead || 'triangle'
      }));
      edges = data.edges.map(e => ({ from: e.from, to: e.to, type: e.type || 'solid', arrowhead: e.arrowhead || 'triangle' }));
      hideMenu();
      alert('Graph loaded successfully');
    }catch(err){
      alert('Failed to load graph: ' + err.message);
    }
  };
  reader.readAsText(file);
  loadGraphInput.value = '';
});

exportCommentsBtn.addEventListener('click', () => {
  const out = nodes.map((n,i) => ({ index: i, title: n.title || '', comment: n.comment || '' }));
  const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'comments.json';
  a.click();
});

/* Export PNG (renders world at DPR) */
exportPngBtn.addEventListener('click', () => {
  const dpr = devicePixelRatioSafe();
  const w = Math.round((canvas.width / dpr) * dpr);
  const h = Math.round((canvas.height / dpr) * dpr);
  const tmp = document.createElement('canvas');
  tmp.width = w; tmp.height = h;
  const tctx = tmp.getContext('2d');
  tctx.scale(dpr, dpr);

  // background
  tctx.fillStyle = '#fff';
  tctx.fillRect(0,0,canvas.width / dpr, canvas.height / dpr);

  // draw grid
  drawGrid(tctx, canvas.width / dpr, canvas.height / dpr, 50);

  // world transform
  tctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
  drawEdgesOnCtx(tctx);
  for(const n of nodes) drawNodeOnCtx(tctx, n);

  const a = document.createElement('a');
  a.href = tmp.toDataURL('image/png');
  a.download = 'graph.png';
  a.click();
});

/* -------------------------
   Wheel zooming
   ------------------------- */
canvas.addEventListener('wheel', (ev) => {
  ev.preventDefault();
  const before = screenToWorld(ev.clientX, ev.clientY);
  const zoomFactor = ev.deltaY < 0 ? 1.12 : 0.88;
  scale *= zoomFactor;
  scale = clamp(scale, 0.2, 4);
  const after = screenToWorld(ev.clientX, ev.clientY);
  // adjust offset so point under cursor stays stable
  offsetX += (after.x - before.x) * scale;
  offsetY += (after.y - before.y) * scale;
});

/* -------------------------
   Undo/Redo & shortcuts
   ------------------------- */
undoBtn.addEventListener('click', undo);
redoBtn.addEventListener('click', redo);

document.addEventListener('keydown', (ev) => {
  if(ev.ctrlKey && !ev.shiftKey && ev.key.toLowerCase() === 's'){
    ev.preventDefault();
    saveAllBtn.click();
  } else if(ev.ctrlKey && !ev.shiftKey && ev.key.toLowerCase() === 'o'){
    ev.preventDefault();
    loadGraphBtn.click();
  } else if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'z'){
    ev.preventDefault();
    if(ev.shiftKey) redo(); else undo();
  }
});

/* -------------------------
   Small UI toggles
   ------------------------- */
drawSquareBtn.addEventListener('click', () => {
  // create a grid-snapped square node at center of view
  const cx = (canvas.width / devicePixelRatioSafe() / 2 - offsetX) / scale;
  const cy = (canvas.height / devicePixelRatioSafe() / 2 - offsetY) / scale;
  pushHistory();
  const grid = 50;
  nodes.push({
    x: Math.round(cx / grid) * grid,
    y: Math.round(cy / grid) * grid,
    color: '#3498db',
    shape: 'square',
    title: '',
    titlePos: 'above',
    comment: ''
  });
});

/* -------------------------
   Initialization
   ------------------------- */
pushHistory(); // initial snapshot

/* End of script */
</script>

</body>
</html>
