<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Shape Drawer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
	--toolbar-h:60px;
	--panel-w:340px;
  }
  
  body {
	margin:0;
	font-family:system-ui,Segoe UI,Roboto,Arial;
	user-select:none;
	-webkit-user-select:none;
  }
  
  #toolbar {
    height:var(--toolbar-h);
    display:flex;
	gap: 0; 
    align-items:center;
    box-sizing:border-box;
	justify-content: space-between;
  }
    
  #toolbar label {
    white-space: nowrap;
  }

  canvas {
    display:block;
	width:100vw;
	height:calc(100vh - var(--toolbar-h));
	background:#fff; cursor:crosshair;
  }

  input[type="number"] { width:80px; }
  
  label {
	display:flex;
	align-items:center;
	gap:6px;
  }

  /* Slide-in panel */
  #panel {
    position: fixed;
    right: 0;
    top: 0;
    width: var(--panel-w);
    height: 100vh;
    background: #ffffff;
	border-left: 1px solid #ccc;
    box-shadow: -4px 0 16px rgba(0,0,0,0.15);
    transform: translateX(100%); /* animation */
    transition: width 0.25s ease;
    z-index: 2000;
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 8px;
	overflow-y: auto;
    overflow-x: hidden;
  }
  
  /* Visible handle at the right edge to toggle panel open/closed */
  #panelHandle {
    position: fixed;
    right: 0;
    top: 40%;
    transform: translateX(50%);
    z-index: 3001;
    width: 28px;
    height: 48px;
    border-radius: 6px 0 0 6px;
    background: #444;
    color: #fff;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: inherit;
    box-shadow: 0 6px 18px rgba(0,0,0,0.15);
    font-weight: 700;
  }

  /* Expand panel */
  #panel.expanded {
    width: 600px;
  }

  /* Expand button */
  .panel-expand-btn {
    position: absolute;
    left: -24px;
    top: 12px;
	z-index: 3000;
    width: 22px;
    height: 22px;
    border: none;
    background: #444;
    color: white;
    border-radius: 4px 0 0 4px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    padding: 0;
    transition: background 0.2s;
  }

  .panel-expand-btn:hover {
    background: #222;
  }

  #panel.open { 
    transform: translateX(0); /* animation */
  }

  #panel header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
  }
  
  #panel h3 { 
	margin:0;
	font-size:16px
  }
  
  #panel .row {
	display:flex;
	gap:8px;
	align-items:center;
	margin-top:6px;
  }
  
  #panel label {
	width:120px;
	font-size:13px;
	color:#333;
  }
  
  #panel input[type="text"], #panel input[type="number"] {
    padding:6px 8px;
    border-radius:6px;
    font-size:13px;
  }
  
  #panel input[type="color"] { 
	width:48px;
	height:32px;
	padding:0;
	border:0;
	background:transparent;
  }
  
  #panel .footer {
	margin-top:auto; /* pushes footer to bottom */
	display:flex;
	justify-content: flex-end;   /* pushes content to the right */
	gap:8px;
  }
  
  #panelClose {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 18px;
    height: 18px;
    font-size: 12px;
    line-height: 18px;
    padding: 0;
    border: none;
    border-radius: 4px;
    background: #ff9999; /* red */
    cursor: pointer;
  }

  #panelClose:hover {
    background: #e53939; /* darker red */
  }

  .muted { 
	color:#666;
	font-size:12px;
  }

  @media (max-width: 900px) { :root { --panel-w: 300px; } }
  
  #textEditor {
    background: transparent;
    outline: none;
    border: none;
	text-align: center;
	padding-top: 30%;
  }
  
  .label-line {
    display: inline-block;
	padding-bottom: 4px;
	border-bottom: 2px solid #000;
	font-weight: bold;
  }
  
  .icon-btn {
    background: #f3f3f3;
    border: 1px solid #ccc;
    padding: 6px;
    border-radius: 6px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  .icon-btn svg {
    fill: #333;
  }

  .icon-btn.active {
    background: #007bff;
    border-color: #006be6;
  }

  .icon-btn.active svg {
    fill: white;
  }
  
  /* for tabs **/
  #panelTabs {
    display: flex;
    border-bottom: 1px solid #ddd;
    margin-bottom: 10px;
  }

  #panelTabs .tab {
    flex: 1;
    padding: 10px;
    background: #f4f4f4;
    border: none;
    cursor: pointer;
    font-size: 14px;
    color: #444;
  }

  #panelTabs .tab.active {
    background: #ffffff;
    border-bottom: 2px solid #007bff;
    color: #007bff;
    font-weight: bold;
  }

  .tabContent { display: none; }
  .tabContent.active { display: block; }
  
  /* Function tab: add textboxes*/
  .textbox {
    width: 100%;
	height: 80px;
	padding: 6px;
	resize: vertical;
	font-size: 13px;
	box-sizing: border-box;
  }

  /* delete textboxes */  
  .textbox-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    padding: 4px;
    font-size: 13px;
    font-weight: bold;
  }

  .textbox-body {
    margin-top: 6px;
    display: block; /* collapsible */
  }
  
  .collapseBtn {
    font-size: 14px;
    cursor: pointer;
    background: none;
    border: none;
    padding: 0 4px;
  }

  /* delete button */
  .deleteTextboxBtn {
    background: #e57373;
    border: none;
    color: white;
    font-size: 12px;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    cursor: pointer;
    text-align: center;
    padding: 0;
    margin-left: 6px;
  }

  .deleteTextboxBtn:hover {
    background: #d32f2f;   /* slightly stronger tone */
  }

  .textbox-header-left {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  /* Function section / search button */
  .service-btn {
    border-radius:10px;
    border:1px solid #ccc;
    background:#fafafa;
    cursor:pointer;
    font-size:14px;
    transition:0.2s;
  }

  .service-btn:hover {
    background:#eaeaea;
  }
  
  .service-btn-img {
    width:35px;
	height:35px;
  }

  #shapeType {
    padding:6px 8px;
    border-radius:6px;
    font-size:13px;
  }
  
  /* text button */
  .toolbar-icon-btn {
    border: none;
    background: none;
    padding: 6px 10px;
    cursor: pointer;
    font-size: 18px;
    padding: 0;
  }

  .toolbar-icon-btn:hover {
    background: #e8e8e8;
  }
 
 .toolbar-icon-btn.active {
    background-color: #0078ff;
    color: white;
  }

  /* Modal API Rest */
  .api-modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.55);
    z-index: 9999;
    justify-content: center;
    align-items: center;
  }

  .api-modal-content {
	display: flex;
	align-items: center;
	gap: 10px;
	background: #fff;
	padding: 8px 12px;
	width: 530px;
	font-family: sans-serif;
  }

  @keyframes popup {
    from { transform: scale(0.85); opacity: 0; }
    to   { transform: scale(1); opacity: 1; }
  }

  .api-close {
    float: right;
    font-size: 28px;
    cursor: pointer;
    color: #444;
  }

  .api-row {
    display: flex;
	align-items: center;
    margin-bottom: 8px;
	background: #fff;
	border: 1px solid #d0d0d0;
    border-radius: 12px;
    padding: 8px 8px;
    width: 525px;
    font-family: sans-serif;
  }

  #apiMethod {
	border: none;
	background: none;
	font-size: 14px;
	padding: 4px;
	cursor: pointer;
  }
  
  #apiMethod:focus {
    outline: none;
  }

  #apiUrl {
    flex: 1;
	border: none;
	font-size: 14px;
	padding: 4px;
  }

  #apiUrl:focus {
    outline: none;
  }

  #apiSendBtn {
    width: 30px;
    height: 30px;
	background: #007bff;
	border: none;
	border-radius: 6px;
    cursor: pointer;
    color: white;
    transition: 0.2s;
  }
  
  #apiSendBtn:hover {
    background: #005fcc;
  }

  #apiBody {
    width: 99%;
    height: 120px;
    margin-bottom: 10px;
    font-family: monospace;
    padding: 8px;
  }

  #apiResponse {
    width: 100%;
    background: #f4f4f4;
    padding: 8px;
    overflow: auto;
    border-radius: 6px;
  }
  
  .hidden{display:none}
</style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- for insert text into a shape -->
  <textarea id="textEditor"
		    style="position:absolute; display:none; resize:none;
				   padding:4px; font-size:16px; 
				   border:1px solid #333; outline:none;">
  </textarea>

  <!-- handle to open/close the panel -->
  <button id="panelHandle" title="Open panel">‚ñ∫</button>

  <!-- Panel for Shape Properties -->
  <div id="panel" aria-hidden="true">
	<div id="toolbar" class="button-row">

		<label>
		  <select id="shapeType">
			<option value="circle">Circle</option>
			<option value="rectangle">Rectangle</option>
		  </select>
		</label>
		
		<button id="insertTextBtn" class="toolbar-icon-btn" title="Insert Text">‚úé</button>

		<button id="undoBtn" class="toolbar-icon-btn" title="Undo">‚Ü©Ô∏è</button>
		
		<button id="redoBtn" class="toolbar-icon-btn" title="Redo">‚Ü™Ô∏è</button>
		
		<button id="loadGraphBtn" class="toolbar-icon-btn" title="Load JSON">üìÇ</button>
		<input id="loadGraphInput" accept=".json" type="file" class="hidden">
		
		<button id="saveAllBtn" class="toolbar-icon-btn" title="Save JSON">üíæ</button>

		<button id="exportPngBtn" class="toolbar-icon-btn" title="Export PNG">üì§</button>

		<button id="toggleGridBtn" class="toolbar-icon-btn" title="Toggle Grid">
		  <svg viewBox="0 0 24 24" width="15" height="15">
			<path d="M3 3h4v4H3V3zm7 0h4v4h-4V3zm7 0h4v4h-4V3zM3 10h4v4H3v-4zm7 0h4v4h-4v-4zm7 0h4v4h-4v-4zM3 17h4v4H3v-4zm7 0h4v4h-4v-4zm7 0h4v4h-4v-4z"/>
		  </svg>
		</button>

		<button id="clearBtn" class="toolbar-icon-btn" title="Clear">üóëÔ∏è</button>
		<button id="deleteBtn" class="toolbar-icon-btn" style="display:none">Delete Selected</button>
	</div>

    <!-- Tabs Header -->
    <div id="panelTabs">
      <button class="tab active" data-tab="styleTab">Design</button>
      <button class="tab" data-tab="textTab">Function</button>
    </div>
  
    <!-- Tab Design -->
    <div id="styleTab" class="tabContent active">
  
		<header>
		  <h3>Shape Properties</h3>
		</header>

		<div class="row">
		  <label class="label-line">Shape</label>
		</div>

		<div class="row">
		  <label>Type</label>
			<select id="propType" disabled>
			  <option value="rectangle">Rectangle</option>
			  <option value="circle">Circle</option>
			</select>
		</div>

		<div class="row">
		  <label>Fill</label>
		  <input id="propFill" type="color">
		</div>

		<div class="row">
		  <label>Border</label>
		  <select id="propBorder">
	   	    <option value="none">None</option>
			<option value="solid">Solid</option>
			<option value="dashed">Dashed</option>
			<option value="bold">Bold</option>
		  </select>
		</div>

		<div class="row">
		  <label>Thickness</label>
		  <input id="propThickness" type="number" min="1" max="20" step="1">
		</div>

		<div class="row">
		  <label>Opacity</label>
		  <input id="propOpacity" type="range" min="0" max="1" step="0.05">
		  <span id="propOpacityVal" class="muted" style="min-width:40px;text-align:right;"></span>
		</div>

		<div class="row">
		  <label>Rounded</label>
		  <input id="propRounded" type="checkbox" title="Rectangle rounded">
		</div>

		<div class="row">
		  <label>X</label>
		  <input id="propX" type="number" step="1">
		</div>

		<div class="row">
		  <label>Y</label>
		  <input id="propY" type="number" step="1">
		</div>

		<div class="row" id="sizeRow">
		  <label>W</label>
		  <input id="propW" type="number" step="1">
		</div>

		<div class="row" id="sizeRowH">
		  <label>H / R</label>
		  <input id="propH" type="number" step="1">
		</div>

		<div class="row">
			<label class="label-line">Text</label>
		</div>
	  
		<div class="row">
		  <label>Text</label>
		  <input id="panelText" type="text" placeholder="shape text">
		</div>

		<div class="row">
		  <label>Font size</label>
		  <input id="panelTextSize" type="number" min="8" max="72" value="16">
		</div>

		<div class="row">
		  <label>Color</label>
		  <input id="panelTextColor" type="color" value="#000000">
		</div>

		<div class="row">
		  <label>Position:</label>
		  <select id="textPosition">
			<option value="center">Center</option>
			<option value="top">Top</option>
			<option value="bottom">Bottom</option>
			<option value="left">Left</option>
			<option value="right">Right</option>
		  </select>
		</div>
		
		<div class="row">
			<label class="label-line">Edge/Arrow</label>
		</div>
		
		<div class="row">
		  <label>Color</label>
		  <input id="propArrowColor" type="color" value="#000000">
		</div>
		
		<div class="row">
		  <label>Type</label>
		  <select id="propArrowType">
	   	    <option value="none">Solid</option>
			<option value="solid">Dashed</option>
			<option value="bold">Bold</option>
		  </select>
		</div>
		
		<div class="row">
		  <label>Arrowhead</label>
		  <select id="propArrowhead">
	   	    <option value="none">Triangle</option>
			<option value="solid">Diamond</option>
			<option value="bold">None</option>
		  </select>
		</div>
		
	</div>

	<!-- Tab Functions -->
	<div id="textTab" class="tabContent">
	
	  <!-- Notes: collapsible wrapper -->
	  <div id="infoSection" style="
        border:1px solid #ccc;
        border-radius:6px;
        overflow:hidden;
        margin-bottom:10px;
      ">
  
        <!-- header collapsible -->
        <div id="infoHeader" style="
          display:flex;
          align-items:center;
          justify-content:space-between;
          padding:6px 10px;
          background:#f1f1f1;
          cursor:pointer;
        ">
          
          <div style="display:flex; align-items:center; gap:8px;">
			<span id="infoToggle" style="font-size:13px; opacity:0.7;">‚ñº</span>
			<h3 style="margin:0; font-size:16px;">Notes</h3>
		  </div>
		
		  <button id="addTextboxBtn"
		    class="icon-btn"
			title="Add Textbox"
			style="
			  border:none;
			  background:transparent;
			  cursor:pointer;
			  font-size:20px;
			  line-height:20px;
			  color:#1a73e8;
			  padding:4px 6px;
			  "
			onmouseover="this.style.color='#0b59c7'"
			onmouseout="this.style.color='#1a73e8'"
		  >Ôºã
		  </button>
        </div>
	
	    <!-- content -->
        <div id="infoContent" style="padding:0px; display:block;">
          <header style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0px;">
          </header>

	      <div id="textList" style="margin-top:0px; display:flex; flex-direction:column; gap:0px;"></div>
      </div>
	  </div>
	
	<!-- Services: collapsible wrapper -->
	<div id="servicesSection" style="
        border:1px solid #ccc;
        border-radius:6px;
        overflow:hidden;
        margin-bottom:10px;
      ">
  
        <!-- header collapsible -->
        <div id="servicesHeader" style="
          display:flex;
          align-items:center;
          justify-content:space-between;
          padding:6px 10px;
          background:#f1f1f1;
          cursor:pointer;
		  gap:8px;
        ">
          		  
	      <span id="servicesToggle" style="font-size:13px; opacity:0.7;">‚ñº</span>
		  <h3 style="font-size:16px;">Services</h3>

		  <!-- Textbox for searching -->
          <input id="servicesInput" 
             type="text" 
             placeholder="Search services..." 
             style="
               flex:1;
               padding:6px 8px;
               border:1px solid #ccc;
               border-radius:4px;
               font-size:14px;
			   width:30px;
             ">

          <!-- Search button -->
          <button id="servicesSearchBtn" class="icon-btn" title="Search" style="
               padding:6px;
               border-radius:6px;
               border:1px solid #ccc;
               background:#f3f3f3;
               cursor:pointer;
          ">
            <svg viewBox="0 0 24 24" width="18" height="18">
            <path d="M15.5 14h-.8l-.3-.3a6 6 0 10-.7.7l.3.3v.8l5 5 1.5-1.5-5-5zm-6 0A4.5 4.5 0 1114 9.5 4.5 4.5 0 019.5 14z"/>
            </svg>
          </button>
        </div>
	
	    <!-- content -->
        <div id="servicesContent" style="padding:5px; display:block;">
		  
		  <!-- Search button -->
		  <div id="servicesGrid" style="
		    display:grid;
			grid-template-columns: repeat(6, 1fr);
			gap:6px;
		  ">

		  <!-- 12 buttons (6 √ó 2) -->
		  <!-- row 1 -->
		  <button class="service-btn" id="apiRestBtn" style="display:flex; align-items:center; justify-content:center;" title="Postman">
		    <img class="service-btn-img" src="images/postman-logo-orange-stacked.svg"
			     alt="Postman">
		  </button>
		  
		  <button class="service-btn" style="display:flex; align-items:center; justify-content:center;" title="API Rest">
		    <img class="service-btn-img" src="images/rest-api-icon.svg"
			     alt="API Rest">
		  </button>
		  
		  <button class="service-btn" style="display:flex; align-items:center; justify-content:center;" title="Email">
		    <img class="service-btn-img" src="images/email.svg"
			     alt="Email">
		  </button>

		  <button class="service-btn" style="display:flex; align-items:center; justify-content:center;" title="Twitter">
		    <img class="service-btn-img" src="images/twitter.svg"
			     alt="Twitter">
		  </button>
		
		  <button class="service-btn" style="display:flex; align-items:center; justify-content:center;" title="Twitter">
		    <img class="service-btn-img" src="images/twitter.svg"
			     alt="Twitter">
		  </button>
		  <button class="service-btn">F</button>
		  
		  <!-- row 2 -->
		  <button class="service-btn">G</button>
		  <button class="service-btn">H</button>
		  <button class="service-btn">I</button>
		  <button class="service-btn">J</button>
		  <button class="service-btn">K</button>
		  <button class="service-btn">L</button>
		  </div>

			<!-- Modal API Rest -->
			<div class="api-modal-content" id="apiModalContent" style="display:none">
			  
			  <span id="apiClose" class="api-close">&times;</span>

			  <h3>Request:</h3>
			  <div class="api-row" style="align-items:center;">
				  
			  <select id="apiMethod">
			   <option>GET</option>
				  <option>POST</option>
				  <option>PUT</option>
				  <option>DELETE</option>
				  <option>PATCH</option>
				</select>

				<input id="apiUrl" type="text" placeholder="https://api.example.com/users" value="https://restcountries.com/v3.1/all?fields=name,capital"/>
				
				<button id="apiSendBtn" title="Send">
				  <span style="display:flex; align-items:center; gap:6px;">
					<svg viewBox="0 0 24 24">
					  <path d="M2 21l21-9L2 3v7l15 2-15 2z" fill="currentColor"/>
					</svg>
				  </span>
				</button>
			  </div>

			  <textarea id="apiBody" placeholder="Write your request" spellcheck="false"></textarea>

			  <h3>Response:</h3>
			  <pre id="apiResponse"></pre>
			  </div>
			</div>
		</div>
  </div>
  	<!--
    <div class="footer">
      <button id="propApply">Apply</button>
      <button id="propReset">Reset</button>
    </div>
	-->
  </div>

<script>

/* -------------------------
   Helper & Utility Functions
   ------------------------- */
//const deepClone = v => JSON.parse(JSON.stringify(v));
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

const $ = id => document.getElementById(id);

/* -------------------- Setup & State -------------------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const toolbar = document.getElementById('toolbar');
const shapeType = document.getElementById('shapeType');
const undoBtn = $('undoBtn'); // use const $ = id => document.getElementById(id);
const redoBtn = $('redoBtn'); // use const $ = id => document.getElementById(id);
const clearBtn = document.getElementById('clearBtn');
const deleteBtn = document.getElementById('deleteBtn');

const panel = document.getElementById('panel');
const panelHandle = document.getElementById("panelHandle");
const propType = document.getElementById('propType');
const propFill = document.getElementById('propFill');
const propBorder = document.getElementById('propBorder');
const propThickness = document.getElementById('propThickness');
const propOpacity = document.getElementById('propOpacity');
const propOpacityVal = document.getElementById('propOpacityVal');
const propRounded = document.getElementById('propRounded');
const propX = document.getElementById('propX');
const propY = document.getElementById('propY');
const propW = document.getElementById('propW');
const propH = document.getElementById('propH');
//const propApply = document.getElementById('propApply');
//const propReset = document.getElementById('propReset');

// properties for edge:
const propArrowColor = document.getElementById('propArrowColor');
const propArrowType = document.getElementById('propArrowType');
const propArrowhead = document.getElementById('propArrowhead');

const panelText = document.getElementById('panelText');
const panelTextSize = document.getElementById('panelTextSize');
const panelTextColor = document.getElementById('panelTextColor');

const textEditor = document.getElementById("textEditor");

const loadGraphInput = $('loadGraphInput');
const saveAllBtn = $('saveAllBtn');

// for Function tab
const textList = document.getElementById("textList");
const addTextboxBtn = document.getElementById("addTextboxBtn");

// for insert text
const insertTextBtn = document.getElementById("insertTextBtn");
let insertingText = false;

// main variables
let shapes = [];         // list of drawn shapes
let selected = null;     // shape currently selected
let tempShape = null;    // shape preview while drawing

// interaction flags
let isDrawing = false; // disable drawing when clicking
let isDragging = false;
let isResizing = false;

let activeHandle = null;

// pointer start
let startX = 0, startY = 0;
let dragOffsetX = 0, dragOffsetY = 0;

let editingShape = null;

let showGrid = true; // grid enabled

// connect nodes with edge
let edges = []; // {from,to,type,head,title,color}
let pendingConnection = null; // when first shape selected
let justCreatedShape = null; // for move shape in the first attempt
let shapeIsMoving = false;
let isEdgeClicked = false;

// collapse/expand behavior
const infoHeader = document.getElementById("infoHeader");
const infoToggle = document.getElementById("infoToggle");
const infoContent = document.getElementById("infoContent");

const servicesHeader = document.getElementById("servicesHeader");
const servicesToggle = document.getElementById("servicesToggle");
const servicesContent = document.getElementById("servicesContent");

// to export the canvas as image PNG
const devicePixelRatioSafe = () => window.devicePixelRatio || 1;

// expand panel
let panelExpanded = false;

/* -------------------------
   State
   ------------------------- */
let history = [];
let redoStack = [];
const HISTORY_LIMIT = 200;

/* -------------------------
   Undo/Redo & shortcuts
   ------------------------- */
undoBtn.addEventListener('click', undo);
redoBtn.addEventListener('click', redo);

/* -------------------------
   Export / Import / Save
   ------------------------- */
saveAllBtn.addEventListener('click', () => {
  const data = {
  shapes: shapes.map(n => ({
  	type:n.type,
    x:n.x,
	y:n.y,
    w:n.w,
	h:n.h,
	border:n.opts.border,
	fill:n.opts.fill,
	thickness:n.opts.thickness,
	opacity:n.opts.opacity
  })),
  edges: edges.map(e => ({
    from:e.from,
	to:e.to,
	color:e.opts.color,
	type:e.opts.type,
	head:e.opts.head,
	text:e.opts.text
  }))
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'export_data.json';
  a.click();
});

loadGraphBtn.addEventListener('click', () => loadGraphInput.click());
loadGraphInput.addEventListener('change', (ev) => {

  const file = ev.target.files[0];

  if(!file)
    return;
  
  const reader = new FileReader();

  reader.onload = (e) => {
    try{
      const data = JSON.parse(e.target.result);
	  
      if(!data.shapes || !data.edges)
	    throw new Error('Invalid format');
	  
      pushHistory();
	  
	  // rebuild all shapes as class instances
      shapes = data.shapes.map(createShape);
	  /*
      shapes = data.shapes.map(n => ({
		type:n.type,
		x:n.x,
		y:n.y,
		w:n.w,
		h:n.h,
		border: n.border,
		fill: n.fill,
		thickness: n.thickness,
		opacity: n.opacity})
	  );*/
	  
	  // rebuild all edges as class instances
      edges = data.edges
			.map(createEdge)
			.filter(e => e !== null);
	  /*
      edges = data.edges.map(e => ({
	    from: e.from,
		to: e.to,
		color: e.color,
		type: e.type,
		head: e.head,
		text: e.text})
	  );
	  */
	  redraw();
		
      //hideMenu();
      alert('Graph loaded successfully');
    }catch(err){
      alert('Failed to load graph: ' + err.message);
    }
  };

  reader.readAsText(file);
  loadGraphInput.value = '';
});

function createShape(s) {
  return new Shape(
    s.type,
    s.x,
    s.y,
    s.w,
    s.h,
    {
      border: s.border,
      fill: s.fill,
      thickness: s.thickness,
      opacity: s.opacity
    }
  );
}

function matchShape(jsonShape) {
  return shapes.find(s =>
    s.type === jsonShape.type &&
    s.x === jsonShape.x &&
    s.y === jsonShape.y &&
    s.w === jsonShape.w &&
    s.h === jsonShape.h
  );
}

function createEdge(ed) {
  const fromShape = matchShape(ed.from);
  const toShape   = matchShape(ed.to);

  if (!fromShape || !toShape) {
    console.warn("Edge refers to missing shape", ed);
    return null;
  }

  return new Edge(fromShape, toShape, {
    color: ed.color,
    type: ed.type,
    head: ed.head,
    text: ed.text
  });
}

/* -------------------- Canvas size -------------------- */

// Call once on page load
resizeCanvasToDisplaySize();

// Optional: also call on window resize
window.addEventListener("resize", () => {
    resizeCanvasToDisplaySize();
    redraw();
});

function resizeCanvasToDisplaySize() {
    const { width, height } = canvas.getBoundingClientRect();

    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;

    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
}

function setCanvasSizeCSS() {
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = (window.innerHeight - toolbar.offsetHeight) + 'px';
  fitCanvas();
}

// canvas auto-scaling
function fitCanvas() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  redraw();
}

window.addEventListener('resize', setCanvasSizeCSS);
setCanvasSizeCSS();

// grid toggle
document.getElementById("toggleGridBtn").addEventListener("click", () => {
  showGrid = !showGrid;
  
  if (showGrid) {
    toggleGridBtn.classList.add("active");
  } else {
    toggleGridBtn.classList.remove("active");
  }
  
  redraw();
});

/* -------------------------
   Initialization
   ------------------------- */
pushHistory();

// initial redraw
redraw();

/* -------------------- Shape Class -------------------- */
/* Edge class */
class Edge {
  constructor(from, to, opts = {}) {
    this.from = from;
    this.to = to;
    this.opts = {
   	  color: opts.color || '#ffffff',
	  type: opts.type, // solid, dashed, bold 
	  head: opts.head || 'none', // triangle, diamond, none
	  text: opts.text 
	}; 
  }
  
  draw(ctx, highlight=false) {
  
    // get shape centers
    const cx1 = this.from.type === "rectangle" ? this.from.x + this.from.w / 2 : this.from.x;
    const cy1 = this.from.type === "rectangle" ? this.from.y + this.from.h / 2 : this.from.y;

    const cx2 = this.to.type === "rectangle" ? this.to.x + this.to.w / 2 : this.to.x;
    const cy2 = this.to.type === "rectangle" ? this.to.y + this.to.h / 2 : this.to.y;
	
	// border intersection points
    const start = getBorderPoint(this.from, cx2, cy2);
    const end = getBorderPoint(this.to, cx1, cy1);

    // draw arrow line
    const headLength = 12;
    const angle = Math.atan2(end.y - start.y, end.x - start.x);

    //if(highlight)
    //	ctx.strokeStyle = "red";
    //else
	  ctx.strokeStyle = this.opts.color;
	  
    ctx.lineWidth = 2; //lineWidth;

    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);

    // arrowhead left
    ctx.lineTo(
        end.x - headLength * Math.cos(angle - Math.PI / 6),
        end.y - headLength * Math.sin(angle - Math.PI / 6)
    );

    // move back to tip
    ctx.moveTo(end.x, end.y);

    // arrowhead right
    ctx.lineTo(
        end.x - headLength * Math.cos(angle + Math.PI / 6),
        end.y - headLength * Math.sin(angle + Math.PI / 6)
    );

    ctx.stroke();
  }
}

/*
1. each shape stores:
Type: "rectangle" or "circle"
Position: x, y
Dimensions: w, h
Rounded corners (rectangle only)
Fill, stroke, opacity
Text & text style

2. methods:
draw(): draws shape on canvas
drawOutline(): red dashed selection outline
drawHandles(): corner handles for resizing
contains(px,py): check if clicked
handleAt(px,py): check if touching a handle
*/
class Shape {
  constructor(type, x, y, w, h, opts = {}) {
    this.type = type;
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.rounded = !!opts.rounded;
    this.radius = (this.rounded && type === 'rectangle') ? Math.max(0, Math.min(Math.abs(w), Math.abs(h)) * 0.1) : 0;

    this.opts = {
      border: opts.border || 'none',
      fill: opts.fill || '#ffffff',
      thickness: opts.thickness || 2,
      opacity: typeof opts.opacity === 'number' ? opts.opacity : 1
    };

    // Text properties
    this.text = opts.text || "";
    this.textSize = opts.textSize || 16;
    this.textColor = opts.textColor || "#000000";
	this.textPosition = opts.textPosition || "center"; 
  }

  draw(ctx, highlight=false) {
    ctx.save();
    ctx.globalAlpha = this.opts.opacity;
	
	const isNoBorder = this.opts.border === "none";
	
    ctx.fillStyle = this.opts.fill;
	
    // add shadow
	ctx.shadowColor = "rgba(0,0,0,0.75)";
	ctx.shadowBlur = 16;
	ctx.shadowOffsetX = 6;
	ctx.shadowOffsetY = 6;
	
	if (!isNoBorder) { // with border
      ctx.strokeStyle = this.opts.borderColor || "black";
      ctx.lineWidth = this.opts.border === 'bold'
		? this.opts.thickness * 3 
		: this.opts.thickness;
    
	  ctx.setLineDash(this.opts.border === 'dashed' ? [6,4] : []);
	} else {
      // No border ‚Üí clear dash + no stroke
      ctx.setLineDash([]);
    }

    // draw shape with shadow
    if (this.type === 'rectangle') {
      drawRoundedOrPlainRect(ctx, this.x, this.y, this.w, this.h, this.rounded ? this.radius : 0);
	  
      ctx.fill();

      // stroke only if border is NOT none
      if (!isNoBorder)
	    ctx.stroke();
		
    } else { // circle
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      ctx.beginPath();
      ctx.arc(this.x, this.y, r, 0, Math.PI*2);
      ctx.fill();
	  
      if (!isNoBorder)
	    ctx.stroke();
    }

    if (highlight && !shapeIsMoving) {
      this.drawOutline(ctx);
      this.drawHandles(ctx); // draw squares corners
    }
	
	// reset shadow
    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
	
	// draw edge without shadow
	ctx.setLineDash([]); // avoid inheriting dashed from shape
    ctx.lineWidth = 2;

    ctx.restore();
  }

  // draw a pixel at the center of a shape
  /*drawCenterPixel(ctx) {
  let cx;
  let cy;
    if (this.type === "rectangle") {
        cx = this.x + this.w / 2,
        cy = this.y + this.h / 2
    } else { 
      // circle ‚Äî your shape.x and shape.y ARE already the center
        cx = this.x;
		cy = this.y;
    }
	ctx.fillStyle = "red";        // or any color
	ctx.fillRect(cx, cy, 1, 1);  // 1 single pixel
  }*/

  drawOutline(ctx) {
    ctx.save();
    ctx.setLineDash([4,4]);
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    if (this.type === 'rectangle') {
      ctx.strokeRect(this.x - 6, this.y - 6, this.w + 12, this.h + 12);
    } else {
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      ctx.beginPath();
      ctx.arc(this.x, this.y, r + 6, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  getHandles() {
    if (this.type === 'rectangle') {
      return [
        {name:'tl', x:this.x, y:this.y},
        {name:'tr', x:this.x + this.w, y:this.y},
        {name:'bl', x:this.x, y:this.y + this.h},
        {name:'br', x:this.x + this.w, y:this.y + this.h},
      ];
    } else {
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      return [
        {name:'tl', x:this.x - r, y:this.y - r},
        {name:'tr', x:this.x + r, y:this.y - r},
        {name:'bl', x:this.x - r, y:this.y + r},
        {name:'br', x:this.x + r, y:this.y + r},
      ];
    }
  }

  drawHandles(ctx) {
    const hs = this.getHandles();
    ctx.save();
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    hs.forEach(h => {
      ctx.beginPath();
      ctx.rect(h.x - 6, h.y - 6, 12, 12);
      ctx.fill();
      ctx.stroke();
    });
    ctx.restore();
  }

  contains(px,py) {
    if (this.type === 'rectangle') {
      const x0 = Math.min(this.x, this.x + this.w);
      const x1 = Math.max(this.x, this.x + this.w);
      const y0 = Math.min(this.y, this.y + this.h);
      const y1 = Math.max(this.y, this.y + this.h);
      return px >= x0 && px <= x1 && py >= y0 && py <= y1;
    } else {
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      const dx = px - this.x;
      const dy = py - this.y;
      return dx*dx + dy*dy <= r*r;
    }
  }

  handleAt(px,py) {
    const hs = this.getHandles();
    for (const h of hs) {
      if (px >= h.x - 6 && px <= h.x + 6 && py >= h.y - 6 && py <= h.y + 6) return h.name;
    }
    return null;
  }
}

/* -------------------- Panel Control -------------------- */
// Open panel (show) ‚Äî reuses your existing panel open logic
function openPanel() {
  panel.classList.add("open");
  panel.setAttribute("aria-hidden", "false");
  panel.style.display = "flex";
  panelHandle.classList.add("hidden"); // hide handle while open
}

// Close panel (hide)
function closePanelUI() {
  panel.classList.remove("open");
  panel.setAttribute("aria-hidden", "true");
  
  panelHandle.classList.remove("hidden"); // show handle when closed
}

// Toggle panel open/close via handle
panelHandle.addEventListener("click", () => {

  if (panel.classList.contains("open")) {
    panelHandle.innerText = "‚ñ∫";
	panelHandle.title = "Open panel";
	
	// remove expand the panel to the left
    panelExpanded = false;
    panel.classList.remove("expanded");
	
	// hidden modal for services
	document.getElementById("apiModalContent").style.display = "none";
  
	closePanelUI();
  } else {
    panelHandle.innerText = "‚óÑ";
	panelHandle.title = "Close panel";
	openPanel();
	}
});

/*
used when selecting a shape

Panel fields are updated with:
	fill color
	border style
	opacity
	text fields
	x/y/w/h
*/
function openPanelForShape(shape) {
  if (!shape) return;
  
  selected = shape;

  syncPanelToShape();
  
  // show toolbar text controls if shape has text (we show them always when selected)
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
  
  // ensure panel is visible (force reflow in odd cases)
  panel.style.display = 'flex';
}

// syncing the Panel
function syncPanelToShape() {

  if (!selected) return;
  
  if(selected.constructor.name === 'Shape') {
	  // ---------------------------
	  // FOR SHAPE
	  // ---------------------------

	  propType.value = selected.type;
	  propFill.value = selected.opts.fill;
	  propBorder.value = selected.opts.border;
	  propThickness.value = selected.opts.thickness;
	  propOpacity.value = selected.opts.opacity;
	  propOpacityVal.innerText = selected.opts.opacity.toFixed(2);
	  propRounded.checked = !!selected.rounded;
	  propX.value = Math.round(selected.x);
	  propY.value = Math.round(selected.y);

	  // for rectangle
	  if (selected.type === 'rectangle') {
		propW.value = Math.round(selected.w);
		propH.value = Math.round(selected.h);
		document.getElementById('sizeRow').style.display = '';
		document.getElementById('sizeRowH').style.display = '';
	  } else { // for circle
		const r = Math.round(Math.max(0, Math.sqrt(selected.w*selected.w + selected.h*selected.h)));
		propW.value = r;
		propH.value = r;
		document.getElementById('sizeRow').style.display = '';
		document.getElementById('sizeRowH').style.display = '';
	  }

	  // text fields
	  panelText.value = selected.text || "";
	  panelTextSize.value = selected.textSize || 16;
	  panelTextColor.value = selected.textColor || "#000000";
  }
  
  if(selected.constructor.name === 'Edge') {
	  // ---------------------------
	  // FOR EDGE
	  // ---------------------------
	  propArrowColor.value = selected.opts.color;
  }

  /*
  // edge fields
  // ---------------------------
  // EDGE / ARROW: ensure object
  // ---------------------------
  // This both creates the object on the selected shape (if missing)
  // and returns a local reference so 'edge' is always defined.
  if (!selected.arrow || typeof selected.arrow !== 'object') {
    // initialize with sensible defaults
    selected.arrow = {
      color: "#000000",
      lineType: "solid", // solid | dashed | bold
      head: "none"       // triangle | diamond | none
    };
  }
  const edge = selected.arrow;

  // Sync panel controls with edge values (use defaults if needed)
  propArrowColor.value = edge.color || "#000000";
  propArrowType.value  = edge.lineType || "solid";
  propArrowhead.value  = edge.head || "none";
  */
}

// Ensure arrow object exists on any selected shape
function ensureArrowObject() {
  if (!selected.arrow) {
    selected.arrow = {
      color: "#000000",
      lineType: "solid",
      head: "none"
    };
  }
}

// for switching tabs
document.querySelectorAll("#panelTabs .tab").forEach(btn => {
  btn.addEventListener("click", () => {
    
  document.querySelectorAll("#panelTabs .tab")
	.forEach(t => t.classList.remove("active"));
  
  btn.classList.add("active");

  const tabId = btn.dataset.tab;

  document.querySelectorAll(".tabContent")
	.forEach(c => c.classList.remove("active"));

  document.getElementById(tabId).classList.add("active");
  });
});

// Function tab, to add textboxes with delete button each one
addTextboxBtn.addEventListener("click", (e) => {
  e.stopPropagation(); // prevents collapsing

  infoContent.style.display = "block";
  infoToggle.textContent = "‚ñº"; // expanded
	
  // wrapper
  const wrapper = document.createElement("div");
  wrapper.className = "textbox-wrapper";
  
  // header
  const header = document.createElement("div");
  header.className = "textbox-header";
  
  const headerLeft = document.createElement("div");
  headerLeft.className = "textbox-header-left";
  
  // collapse button
  const collapseBtn = document.createElement("button");
  collapseBtn.className = "collapseBtn";
  collapseBtn.textContent = "‚ñº";
  collapseBtn.style.marginRight = "6px";
  
  // title
  const title = document.createElement("span");
  title.contentEditable = "true";
  title.textContent = "Add title";
  title.style.outline = "none";      // removes border when editing
  title.style.cursor = "text";
  title.style.whiteSpace = "nowrap";
  title.style.overflow = "hidden";
  title.style.textOverflow = "ellipsis";
  title.spellcheck = false;          // optional
  
  // prevent title multiline
  title.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      title.blur();
    }
  });

  // limit to 30 characters
  title.addEventListener("input", () => {
    if (title.textContent.length > 30) {
      title.textContent = title.textContent.slice(0, 30);

    // move caret to end
    const range = document.createRange();
    const sel = window.getSelection();
    range.selectNodeContents(title);
    range.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range);
    }
  });

  // don't collapse section when clicking title
  title.addEventListener("click", (e) => {
    e.stopPropagation();
  });

  // delete button
  const removeBtn = document.createElement("button");
  removeBtn.className = "deleteTextboxBtn";
  removeBtn.textContent = "√ó";
  removeBtn.title = "Remove textbox";
  
  // body
  const body = document.createElement("div");
  body.className = "textbox-body";
  
  // create textbox
  const box = document.createElement("textarea");
  box.className = "textbox";
  box.placeholder = "Write here...";

  body.appendChild(box);

  // collapse/expand handling
  collapseBtn.addEventListener("click", (ev) => {
    ev.stopPropagation();
    
	if (body.style.display === "none") {
      body.style.display = "block";
      collapseBtn.textContent = "‚ñº";
    } else {
      body.style.display = "none";
      collapseBtn.textContent = "‚ñ∫";
    }
  });

  // remove textbox
  removeBtn.addEventListener("click", () => wrapper.remove());

  // order
  headerLeft.appendChild(collapseBtn);
  headerLeft.appendChild(title);
  
  header.appendChild(headerLeft); // add header
  header.appendChild(removeBtn); // add delete button

  wrapper.appendChild(header);
  wrapper.appendChild(body); // add textbox

  textList.appendChild(wrapper);
});

// Activate text insert mode
insertTextBtn.addEventListener("click", () => {
  insertingText = !insertingText;
  insertTextBtn.classList.toggle("active", insertingText);
});

// Function / Notes: collapse/expand behabior
infoHeader.addEventListener("click", () => {
  const isOpen = infoContent.style.display !== "none";

  if (isOpen) {
    infoContent.style.display = "none";
    infoToggle.textContent = "‚ñ∫"; // collapsed
  } else {
    infoContent.style.display = "block";
    infoToggle.textContent = "‚ñº"; // expanded
  }
});

// Function / Services: collapse/expand behabior
servicesHeader.addEventListener("click", () => {
  const isOpen = servicesContent.style.display !== "none";

  if (isOpen) {
    servicesContent.style.display = "none";
    servicesToggle.textContent = "‚ñ∫"; // collapsed
  } else {
    servicesContent.style.display = "block";
    servicesToggle.textContent = "‚ñº"; // expanded
  }
});


shapeType.addEventListener("click", () => {
    insertingText = false;
	insertTextBtn.classList.remove("active");
});

// export to image PNG
document.getElementById("exportPngBtn").addEventListener("click", () => {

  // Use the real pixel-sized canvas (your fitCanvas() already sets canvas.width/height)
  const src = canvas;

  // Create temporary canvas with the SAME pixel dimensions
  const tmp = document.createElement('canvas');
  tmp.width = src.width;
  tmp.height = src.height;
  const tctx = tmp.getContext('2d');

  // 1. Paint a white background covering the whole pixel canvas
  tctx.fillStyle = '#ffffff';
  tctx.fillRect(0, 0, tmp.width, tmp.height);

  // 2. Draw the source canvas ON TOP (pixel-perfect)
  // drawImage will copy the full pixel content (including everything you've drawn).
  tctx.drawImage(src, 0, 0);

  // 3. Export (use toBlob for better memory behavior)
  tmp.toBlob((blob) => {
    if (!blob) return;
    
	const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'canvas_export.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }, 'image/png');
});

// live updates for shape from panel
propFill.addEventListener('input', (e) => { 
  debugger;
  if (!selected) return;

  const fill = e.target.value;
  selected.opts.fill = fill;

  // auto-darken border if border is not "none"
  if (selected.opts.border !== "none") {
    selected.opts.borderColor = darkenColor(fill, 25); // 25% darker
  }

  pushHistory();
  redraw();
});

// live updates for edge from panel
propArrowColor.addEventListener('input', (e) => { 
  debugger;

  if (!selected) return;

  const color = e.target.value
  selected.opts.color = color;
  
  //ensureArrowObject();
  //selected.arrow.color = e.target.value;
  pushHistory();
  redraw();
});

// auto-darken border for shape: small color-darkening helper
function darkenColor(hex, percent = 20) {
  // Convert HEX ‚Üí RGB
  const num = parseInt(hex.replace("#",""), 16);
  let r = (num >> 16) & 255;
  let g = (num >> 8) & 255;
  let b = num & 255;

  // Convert RGB ‚Üí HSL
  r/=255; g/=255; b/=255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  let h, s, l = (max+min)/2;

  if (max===min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > .5 ? d / (2-max-min) : d/(max+min);
    switch(max){
      case r: h = (g-b)/d + (g<b?6:0); break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h /= 6;
  }

  // DARKEN L%
  l = Math.max(0, l - percent/100);

  // Convert HSL ‚Üí RGB
  let q = l < .5 ? l*(1+s) : l + s - l*s;
  let p = 2*l - q;
  const hue2rgb = (p,q,t)=>{
    if(t<0) t+=1;
    if(t>1) t-=1;
    if(t<1/6) return p+(q-p)*6*t;
    if(t<1/2) return q;
    if(t<2/3) return p+(q-p)*(2/3-t)*6;
    return p;
  };

  r = hue2rgb(p,q,h+1/3);
  g = hue2rgb(p,q,h);
  b = hue2rgb(p,q,h-1/3);

  // RGB ‚Üí HEX
  return "#" + 
      Math.round(r*255).toString(16).padStart(2,"0") +
      Math.round(g*255).toString(16).padStart(2,"0") +
      Math.round(b*255).toString(16).padStart(2,"0");
}

// border for shape
propBorder.addEventListener('change', () => {
  if(selected){
    selected.opts.border = propBorder.value;
	pushHistory();
	redraw();
  }
});


// arrow type for edge
propArrowType.addEventListener('change', (e) => { 
  if (!selected) return;

  ensureArrowObject();
  selected.arrow.lineType = e.target.value;  // solid, dashed, bold
  pushHistory();
  redraw();
});

// arrowhead type
propArrowhead.addEventListener('change', (e) => { 
  if (!selected) return;

  ensureArrowObject();
  selected.arrow.head = e.target.value;  // triangle, diamond, none
  pushHistory();
  redraw();
});

propThickness.addEventListener('input', () => { 
  if(selected){
    selected.opts.thickness = +propThickness.value;
	pushHistory();
	redraw();
  }
});

propOpacity.addEventListener('input', () => {
  if(selected){
    selected.opts.opacity = +propOpacity.value;
	propOpacityVal.innerText = (+propOpacity.value).toFixed(2);
	pushHistory();
	redraw();
  }
});

// rounded corners
propRounded.addEventListener('change', () => { 
	if(selected && selected.type === 'rectangle'){ 
		selected.rounded = propRounded.checked; 
		if(selected.rounded) 
			selected.radius = Math.max(0, Math.min(Math.abs(selected.w), Math.abs(selected.h)) * 0.1); 
			pushHistory();
			redraw(); 
	}
});

// edge type
propArrowType.addEventListener('change', () => {
  if(selected){
    selected.opts.type = propArrowType.value;
	pushHistory();
	redraw();
  }
});

// edge arrowhead
propArrowhead.addEventListener('change', () => {
  if(selected){
    selected.opts.type = propArrowhead.value;
	pushHistory();
	redraw();
  }
});

[propX, propY].forEach(inp => inp.addEventListener('input', () => {
  if(selected){
    selected.x = +propX.value;
	selected.y = +propY.value;
	pushHistory();
	redraw();
  }}
));

propW.addEventListener('input', () => {
  if(!selected)
    return;

  if(selected.type === 'rectangle'){
    selected.w = +propW.value;
	
	if(selected.rounded)
	  selected.radius = Math.max(0, Math.min(Math.abs(selected.w), Math.abs(selected.h)) * 0.1);
  } else {
    selected.w = +propW.value;
	selected.h = +propW.value;
  }
  pushHistory();
  redraw();
});

propH.addEventListener('input', () => {
  if(!selected)
    return;

  if(selected.type === 'rectangle') {
    selected.h = +propH.value;

	if(selected.rounded)
      selected.radius = Math.max(0, Math.min(Math.abs(selected.w), Math.abs(selected.h)) * 0.1);
  } else {
    const r = +propH.value; selected.w = r; selected.h = r;
  }
  pushHistory();
  redraw();
});

//propApply.addEventListener('click', () => { applyPanelToShape(false); closePanel(); });
//propReset.addEventListener('click', () => { syncPanelToShape(); });

/* -------------------- Pointer Events -------------------- */
// when mouse click
canvas.addEventListener('pointerdown', (ev) => {

  ev.preventDefault();

  canvas.setPointerCapture(ev.pointerId);
  
  const pos = screenToCanvas(ev); // autoscaling

  activeHandle = null;
  isResizing = false;
  shapeIsMoving = false;

  // If we are editing text, finish it when the user clicks the canvas
  if (editingShape) {
    finishInlineEdit();
  }

  // -----------------------------
  // HANDLE RESIZE HANDLES
  // -----------------------------
  // check if click hits a resize handle -> start resizing
  if (selected && !isEdgeClicked) {
	isEdgeClicked = false;
    const hn = selected.handleAt(pos.x, pos.y);
    if (hn) {
      activeHandle = hn;
      isResizing = true;
      startX = pos.x;
	  startY = pos.y;
      return;
    }
  }
  
  // -----------------------------
  // HIT SHAPES
  // -----------------------------
  // check if click hits a shape ‚Üí select + drag
  selected = null;
  let hit = null;
  
  for (let i = shapes.length - 1; i >= 0; i--) {
    if (shapes[i].contains(pos.x, pos.y)) {
      hit = shapes[i];
	  selected = hit;
	  isEdgeClicked = false;	  
	  
      // ----------------------------------------------------------
      // CONNECTION MODE
      // ----------------------------------------------------------
	  // for connection shapes
	  if (pendingConnection === null) {
	  
        // first click ‚Üí start connection
        pendingConnection = hit;
      } else if (pendingConnection && hit !== pendingConnection) {
	  
        // second click ‚Üí create arrow
		const newEdge = new Edge(
		pendingConnection, // from shape Object
        hit, // to shape Object
		{
		  color: "#000000",
		  type: "solid",
		  head: "triangle",
		  text: "Text"
		});
        
		pushHistory();
		edges.push(newEdge);

        pendingConnection = null;
      }

      // ----------------------------------------------------------
      // NORMAL CLICK: SELECT + DRAG
      // ----------------------------------------------------------
      justCreatedShape = null; // reset if it was set
	  //mouseDownInsideShape = true;
		
	  // only reached if NOT in connection mode
      isDragging = true;
      dragOffsetX = pos.x - selected.x;
      dragOffsetY = pos.y - selected.y;
	  
      // open panel for this shape
      //openPanelForShape(selected);
      redraw();
      return;
    }
  }

  // -----------------------------
  // HIT EDGE
  // -----------------------------
  // if user clicked an edge, select it and open panel
  for (let i = edges.length - 1; i >= 0; i--) {

	hit = edges[i];
    //const e = edges[i];
    const pts = getEdgePoints(hit); // { x1,y1,x2,y2 }

    if (isPointNearLine(pos.x, pos.y, pts.x1, pts.y1, pts.x2, pts.y2, 8)) {
      // prevent shape creation
      selected = hit;
	  //selected = e;
	  isEdgeClicked = true;
      // open panel like shapes
      //openPanelForEdge(e);
      redraw();
      return; // IMPORTANT: stop pointerdown processing so no new shape is created
    }
  }
  
  // clicking empty canvas cancels connection mode
  pendingConnection = null;

  // -----------------------------
  // CREATE NEW SHAPE
  // -----------------------------
  // if click did NOT hit any shape ‚Üí create a new shape (circle by default) instantly
  if (!selected) {
	isEdgeClicked = false;
	
    // snap-to-grid
    let x = pos.x, y = pos.y;
    
	if (showGrid) {
      x = snapToGrid(x);
      y = snapToGrid(y);
    }
	
	//let newShape;
	
	// TEXT INSERT MODE: for inserting text on canvas
	if(insertingText) {
      const newShapeText = new Shape(
      'rectangle',       	 // rectangle
      x,            	 	 // center adjust
      y,
      100,                    // default width
      50,                    // default height
      {
        fill: "transparent",
        border: "none",
        thickness: 2,
        opacity: 1,
        rounded: false,
		text: "Text"
      });
	  
	  pushHistory();
	  shapes.push(newShapeText);
      justCreatedShape = newShapeText; // for move shape in the first attempt
      selected = null; // do not auto-select (resizing) the new shape
      redraw();
      //return;
	}
	// NORMAL SHAPE MODE
	else {
	  const newShape = new Shape(
      shapeType.value,       // rectangle or circle
      x,            	 	 // center adjust
      y,
      shapeType.value == 'rectangle' ? 100 : 10, // default width
      shapeType.value == 'rectangle' ? 50 : 10,  // default height
      {
        fill: "transparent", /*#ffffff",*/
        border: "solid",
        thickness: 2,
        opacity: 1,
        rounded: false
      });
	  pushHistory();
	  shapes.push(newShape);
      justCreatedShape = newShape;  // for move shape in the first attempt
	  selected = null; // do not auto-select (resizing) the new shape
	  //selected = newShape;
	  redraw();
	  return;   // stop normal drawing logic
	}

	//openPanelForShape(selected);
	redraw();
	return;   // stop normal drawing logic
  }

  // start drawing a new shape
  isDrawing = false; // disable drawing when clicking
  startX = pos.x;
  startY = pos.y;
  tempShape = null;
  
  // when starting to draw, close panel (avoid overlap)
  //closePanel();
});

// when mouse is moving
canvas.addEventListener('pointermove', (ev) => {
  const pos = screenToCanvas(ev);
  
  // for drawing
  if (isDrawing) {
	// drawing a rectangle
    if (shapeType.value === 'rectangle') {
      const x = Math.min(startX, pos.x);
      const y = Math.min(startY, pos.y);
      const w = Math.abs(pos.x - startX);
      const h = Math.abs(pos.y - startY);
      tempShape = new Shape('rectangle', x, y, w, h, {
        //border: borderType.value,
        //fill: fillColor.value,
        //thickness: +thickness.value,
        //opacity: +opacity.value
        //rounded: willBeRounded
      });
    } else { // drawing a circle
      const dx = pos.x - startX;
      const dy = pos.y - startY;
      const r = Math.max(0, Math.sqrt(dx*dx + dy*dy));
      tempShape = new Shape('circle', startX, startY, r, r, {
        //border: borderType.value,
        //fill: fillColor.value,
        //thickness: +thickness.value,
        //opacity: +opacity.value
      });
    }
    redraw();
    return;
  }

  // for dragging
  if (isDragging && selected) {
    shapeIsMoving = true;
	
	pendingConnection = null; // cancel connection mode with arrow after moving a shape
	
    let newX = pos.x - dragOffsetX;
    let newY = pos.y - dragOffsetY;

    // snap-to-grid
    if (showGrid) {
      newX = snapToGrid(newX);
      newY = snapToGrid(newY);
    }

    selected.x = newX;
    selected.y = newY;
  
    syncPanelToShape();
	pushHistory();
    redraw();
    return;
  }

  // for resizing
  if (isResizing && selected && activeHandle) {
    resizeShape(selected, activeHandle, pos.x, pos.y);
    syncPanelToShape();
	pushHistory();
    redraw();
    return;
  }

  //debugger;
  if(isDrawing || isResizing || isDragging) {
	  // update cursor
	  let cursor = 'crosshair'; // for isDrawing
	  
	  if (selected) { // is shape is selected
	  
		if (selected.handleAt(pos.x, pos.y))
		  cursor = 'nwse-resize'; // for resizing
		else if (selected.contains(pos.x,pos.y))
		  cursor = 'grab'; // for dragging, cursor over the body of the selected shape
	  } else {
		for (let i = shapes.length - 1; i >= 0; i--) {
		  if (shapes[i].contains(pos.x,pos.y)) {
			cursor = 'pointer';
			break;
		  }
		}
	  }
  
    canvas.style.cursor = cursor;
  }
});

// when mouse is up
canvas.addEventListener('pointerup', (ev) => {
debugger;
  ev.preventDefault();
  canvas.releasePointerCapture(ev.pointerId);
  const pos = screenToCanvas(ev);
  
  // If user clicked empty space ‚Üí cancel pending connection
  if (!selected) {
    pendingConnection = null;
	return;
  }

  syncPanelToShape();

  // for resizing
  if (isResizing) {
    pushHistory();
    isResizing = false;
    activeHandle = null;
    syncPanelToShape();
	pushHistory();
    redraw();
    return;
  }

  // for dragging
  if (isDragging) {
    pushHistory();
    isDragging = false;
    syncPanelToShape();
	pushHistory();
    redraw();
    return;
  }

  // for drawing
  if (isDrawing && tempShape) {
    pushHistory();
    if ((tempShape.type === 'rectangle' && tempShape.w > 4 && tempShape.h > 4) ||
        (tempShape.type === 'circle' && Math.sqrt(tempShape.w*tempShape.w + tempShape.h*tempShape.h) > 4)) {

      shapes.push(tempShape);
      selected = tempShape;
	  
      // open panel for new shape
      //openPanelForShape(selected);
    }
    tempShape = null;
  }

  isDrawing = false;
  pendingConnection = null;
  redraw();
});

canvas.addEventListener('pointercancel', (ev) => {
  //debugger;
  if (isDrawing) { isDrawing = false; tempShape = null; redraw(); }
  if (isDragging) isDragging = false;
  if (isResizing) { isResizing = false; activeHandle = null; }
});

clearBtn.addEventListener('click', () => {
  shapes = [];
  selected = null;
  tempShape = null;
  closePanelUI();
  //closePanel();
  redraw();
});

deleteBtn.addEventListener('click', () => {
  if (selected) { 
    shapes = shapes.filter(s => s !== selected); 
	selected = null; 
	closePanelUI();
	//closePanel(); 
	redraw(); 
  }
});

// when change position of text in a shape
document.querySelector("#textPosition").addEventListener("change", (e) => {
  if (!selected) return;
    selected.textPosition = e.target.value;
  redraw();
});

// when press some key
// it can be replaced for:
/*window.addEventListener("keydown", (e) => {
  if (e.ctrlKey && e.key === "z") undo();
  if (e.ctrlKey && e.key === "y") redo();
});
*/
document.addEventListener('keydown', (e) => {

  pendingConnection = null;
		
  // when right-clicking outside the canvas, close editor
  document.addEventListener("contextmenu", (ev) => {
		
	    if (!editingShape) return; // no editor open -> do nothing

		// clicked inside the text editor ‚Üí keep editing
		if (textEditor.contains(ev.target)) return;
			
		// clicked on canvas ‚Üí canvas handler above handles it
		if (ev.target === canvas) return;
			
	    // otherwise right-click outside ‚Üí close editor
		ev.preventDefault();
		finishInlineEdit();
  });
	
  if(e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 's'){
    e.preventDefault();
    //saveAllBtn.click();
  } else if(e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'o'){
    e.preventDefault();
    //loadGraphBtn.click();
  } else if(e.ctrlKey && e.key === "z"){
    e.preventDefault();
	undo();
  } else if(e.ctrlKey && e.key === "y"){
	  redo();
  } else if (e.key === 'Delete' && selected) { 
  
    shapes = shapes.filter(s => s !== selected);
	
	edges = edges.filter(s => s !== selected);
	
    selected = null;
	
	closePanelUI();
	redraw();
  } else if(e.key === 'Escape') { // ESC to cancel editing
  	// Save changes when user leaves input or presses Enter
    finishInlineEdit();
		
	closePanelUI();
	selected = null;
	redraw(); 
  }
});

// deselect on canvas click when clicking empty area (and close panel)
// or when ending drawing a shape
/*canvas.addEventListener('click', (ev) => {
  const pos = screenToCanvas(ev);
  let hit = false;
  
  // If we are editing text, finish it when the user clicks the canvas
  if (editingShape) {
    finishInlineEdit();
  }
	
  for (let i = shapes.length - 1; i >= 0; i--) {
	if (shapes[i].contains(pos.x,pos.y)) {
	  hit = true;
	  break;
    }
  }
  
  if (!hit) { 
    //selected = null;
	//closePanel();
	redraw();
  }
});
*/

// when double-left click
canvas.addEventListener('dblclick', (ev) => {
  ev.preventDefault();
  const pos = screenToCanvas(ev);

  selected = null; // reset before hit detection

  // 1. Try selecting a SHAPE first (so shapes take precedence)
  for (let i = shapes.length - 1; i >= 0; i--) {
    if (shapes[i].contains(pos.x, pos.y)) {
      selected = shapes[i];
      openPanelForShape(selected);
      redraw();
      startInlineEdit(selected);
      return; // stop here ‚Äî shape handled
    }
  }

  // 2. If no shape selected, try selecting an EDGE
  for (let i = edges.length - 1; i >= 0; i--) {
    const e = edges[i];
    const pts = getEdgePoints(e);
    if (isPointNearLine(pos.x, pos.y, pts.x1, pts.y1, pts.x2, pts.y2, 10)) {
      // Select edge (use selectedEdge if you prefer)
      selected = e;
      openPanelForEdge(e); // your panel opener for edges
      redraw();
      return;
    }
  }

  // if neither shape nor edge -> nothing to do
});

// when right-clicking the canvas then close editor
canvas.addEventListener("contextmenu", (e) => {
    if (editingShape) {
        e.preventDefault();   // prevent default context menu
        finishInlineEdit();
    }
});

/* -------------------- Toolbar text controls binding -------------------- */

// Panel text bindings
panelText.addEventListener('input', () => {
  if (selected) { 
    selected.text = panelText.value;
	redraw();
  }
});

panelTextSize.addEventListener('input', () => {
  if (selected) {
    selected.textSize = +panelTextSize.value;
	redraw();
  }
});

panelTextColor.addEventListener('input', () => {
  if (selected) {
    selected.textColor = panelTextColor.value;
	redraw();
  }
});

// save changes when user leaves input or presses Enter
textEditor.addEventListener("blur", finishInlineEdit);

textEditor.addEventListener("input", () => {
    autoResizeTextEditor();
});

/* -------------------- Drawing Helpers -------------------- */
// start text editing inside the shape
function startInlineEdit(shape) {

    editingShape = shape;

    textEditor.value = shape.text || "";

	// remove old text behind of editing
	shape.text = "";
	redraw();
	
	//textEditor.style.textAlign = "center";
	textEditor.style.background = "transparent";
	textEditor.style.border = "none";        // optional
	textEditor.style.outline = "none";       // optional
	
	// NOT wrap, shape text can be longer than box
    textEditor.style.width = shape.w + "px";
    textEditor.style.height = shape.h + "px";

	const { cx, cy } = getCenter(shape);
	//console.log("Center:", cx, cy);
	//console.log("shape.x", shape.x);
	//console.log("shape.y", shape.y);
	
	//textEditor.style.left = (shape.x) - 10 + "px";
    //textEditor.style.top = (shape.y) - 10 + "px";
	
	//textEditor.style.left = (shape.x - cx*0.0262) + "px";
    //textEditor.style.top = (shape.y + cy*0.0425) + "px";
    
	textEditor.style.left = (shape.x + canvas.offsetLeft) + "px";
    textEditor.style.top = (shape.y + canvas.offsetTop) + "px";
	console.log("width", shape.w);
	console.log("height", shape.h);
	
    // disable wrapping
    textEditor.style.whiteSpace = "nowrap";
    textEditor.style.overflow = "hidden";
	
	// center text
    //textEditor.style.textAlign = "center";
    //centerEditorText(shape);
	
    textEditor.style.display = "block";
    textEditor.focus();
    textEditor.select();
}

// get center of any shape
function getCenter(shape) {
    if (shape.type === "rectangle") {
        return {
            cx: shape.x + shape.w / 2,
            cy: shape.y + shape.h / 2
        };
    } else { // circle
        return {
			cx: shape.x,
            cy: shape.y
        };
    }
}

// rounded rect drawing
function drawRoundedOrPlainRect(ctx, x, y, w, h, radius) {
  const absW = Math.abs(w), absH = Math.abs(h);
  const r = Math.max(0, Math.min(radius || 0, Math.min(absW, absH) / 2));
  const x0 = w >= 0 ? x : x + w;
  const y0 = h >= 0 ? y : y + h;
  const W = absW, H = absH;

  if (!r) {
    ctx.beginPath();
    ctx.rect(x0, y0, W, H);
    //ctx.fill();
    //ctx.stroke();
    return;
  }

  ctx.beginPath();
  ctx.moveTo(x0 + r, y0);
  ctx.lineTo(x0 + W - r, y0);
  ctx.arcTo(x0 + W, y0, x0 + W, y0 + r, r);
  ctx.lineTo(x0 + W, y0 + H - r);
  ctx.arcTo(x0 + W, y0 + H, x0 + W - r, y0 + H, r);
  ctx.lineTo(x0 + r, y0 + H);
  ctx.arcTo(x0, y0 + H, x0, y0 + H - r, r);
  ctx.lineTo(x0, y0 + r);
  ctx.arcTo(x0, y0, x0 + r, y0, r);
  ctx.closePath();
  //ctx.fill();
  //ctx.stroke();
}

// grid: light dots every 10px, stronger dots every 50px
function drawGrid(ctx, step = 10) {
  const width = canvas.width;
  const height = canvas.height;

  ctx.save();
  ctx.beginPath();

  // small dots every 10px
  ctx.fillStyle = "#e2e2e2";

  for (let x = 0; x < width; x += step) {
    for (let y = 0; y < height; y += step) {
      ctx.fillRect(x, y, 1, 1);
    }
  }

  // stronger dots every 50px
  ctx.fillStyle = "#c9c9c9";
  for (let x = 0; x < width; x += 50) {
    for (let y = 0; y < height; y += 50) {
      ctx.fillRect(x, y, 1.7, 1.7);
    }
  }

  ctx.restore();
}

// snap-tp-grid
function snapToGrid(value, step = 10) {
  return Math.round(value / step) * step;
}

/*
clears the canvas and draw:
  1. All shapes
  2. Text inside shapes
  3. The temp shape (if drawing)
*/
function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // draw grid behind everything
  if (showGrid)
    drawGrid(ctx);
	
  // draw shapes
  shapes.forEach(s => {
    //s.drawCenterPixel(ctx);
	s.draw(ctx, s === selected);
	renderText(ctx, s);
  });
  
  // draw edges
  edges.forEach(e => {
    e.draw(ctx, e === selected);
  });
	
  // draw temp shape (preview)
  if (tempShape) tempShape.draw(ctx, false);
  
  //requestAnimationFrame(redraw);
}
//requestAnimationFrame(redraw);

// coordinate transforms
function screenToCanvas(e) {
  const r = canvas.getBoundingClientRect();
  return { 
    x: e.clientX - r.left,
	y: e.clientY - r.top
  };
}

function screenToWorld(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const cx = clientX - rect.left;
  const cy = clientY - rect.top;
  return { 
    x: (cx - offsetX) / scale,
	y: (cy - offsetY) / scale
  };
}

/*
Resizing Shapes: uses 4 corners handles:
	tl = top-left
	tr = top-right
	bl = bottom-left
	br = bottom-right
*/
function resizeShape(shape, handle, mx, my) {

  // snap-to-grid
  if (showGrid) {
    mx = snapToGrid(mx);
    my = snapToGrid(my);
  }
  
  // for rectangle
  if (shape.type === 'rectangle') {
    let x = shape.x, y = shape.y, w = shape.w, h = shape.h;
    const right = x + w;
    const bottom = y + h;

    if (handle === 'tl') {
      x = mx; y = my;
      w = right - mx;
      h = bottom - my;
    } else if (handle === 'tr') {
      y = my;
      w = mx - x;
      h = bottom - my;
    } else if (handle === 'bl') {
      x = mx;
      w = right - mx;
      h = my - y;
    } else if (handle === 'br') {
      w = mx - x;
      h = my - y;
    }

    if (w < 0) { x = x + w; w = Math.abs(w); }
    if (h < 0) { y = y + h; h = Math.abs(h); }

    shape.x = x; shape.y = y; shape.w = w; shape.h = h;

    if (shape.rounded) {
      shape.radius = Math.max(0, Math.min(shape.w, shape.h) * 0.1);
    }
  } else { // for circle
    const dx = mx - shape.x;
    const dy = my - shape.y;
    const r = Math.max(2, Math.sqrt(dx*dx + dy*dy));
    shape.w = r;
	shape.h = r;
  }
}

// saves the text before the textarea width resets
function finishInlineEdit() {
	//debugger;
	console.log("finishInlineEdit")
    if (!editingShape) return;
	
    // save exactly the text the user wrote (NO wrapping)
    editingShape.text = textEditor.value;

	// hide editor
	textEditor.style.display = "none";
    editingShape = null;
	
	// redraw canvas with properly wrapped text
    redraw();
}

// adjusts height and wigth
function autoResizeTextEditor() {
	textEditor.style.width = editingShape.w + "px"; // keep width locked
    textEditor.style.height = "auto"; // reset
    textEditor.style.height = (textEditor.scrollHeight) + "px"; // fit to content
}

/*
wraps text so it fits inside the shape width
all text handling + wrapping + alignment

Draws the text according to:
	Position (center, top, bottom, left, right)
	Color
	Font size
	Alignment inside the shape
*/
function renderText(ctx, shape) {
    if (!shape.text) return;

    const padding = 6;
    const lineHeight = 16;
	
    ctx.save();
    ctx.fillStyle = shape.textColor || "#000";
    ctx.font = `${shape.textSize || 16}px sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // split text into lines (no wrapping)
    const lines = shape.text.split("\n");
	
    let x = shape.x + shape.w / 2;
    let y = shape.y + shape.h / 2;

    switch (shape.textPosition) {
        case "top":
            //x = shape.x;
            y = shape.y - lineHeight * (lines.length) - padding;
            break;
        case "bottom":
            //x = shape.x;
            y = shape.y + shape.h + lineHeight + padding;
            break;
        case "left":
		    ctx.textAlign = "right"; // text ends at the border
			x = shape.x - padding;   // just outside the left border
            //x = shape.x - shape.w;
            //y = shape.y + lineHeight;
            break;
        case "right":
		    ctx.textAlign = "left";                 // text starts at the border
			x = shape.x + shape.w + padding;        // just outside the right border
            //x = shape.x + shape.w + padding+6;
            //y = shape.y + lineHeight;
            break;
        default:
            // center (default)
            break;
    }

    // draw all lines
    for (let line of lines) {
        ctx.fillText(line, x, y);
        y += lineHeight;
    }
	
    //ctx.fillText(shape.text, x, y);
    ctx.restore();
}

function updateShapePropertiesPanel(shape) {
    if (!shape) return;

    document.getElementById("shapeFill").value = shape.opts.fill;
    document.getElementById("shapeBorder").value = shape.opts.border;
    document.getElementById("shapeOpacity").value = shape.opts.opacity * 100;
    document.getElementById("textSize").value = shape.textSize;
    document.getElementById("textColor").value = shape.textColor;

    // sync text position dropdown
    document.getElementById("textPosition").value = shape.textPosition;
}

function centerEditorText(shape) {
    const approxOffset = (shape.h / 2) - 10;
    textEditor.style.paddingTop = approxOffset + "px";
}

// get border from shape
function getBorderPoint(shape, targetX, targetY) {
    const isCircle = shape.type === "circle";

    // center
    const cx = isCircle ? shape.x : shape.x + shape.w / 2;
    const cy = isCircle ? shape.y : shape.y + shape.h / 2;

    const dx = targetX - cx;
    const dy = targetY - cy;

    // Circle (uses shape.w as radius)
    if (isCircle) {
        const r = Math.abs(shape.w); // radius = shape.w (your model)
        const angle = Math.atan2(dy, dx);
		const f = 1.4; // factor 1.4 to put arrow at the edge of the circle
		
        return {
            x: cx + Math.cos(angle) * r * f,
            y: cy + Math.sin(angle) * r * f
        };
    }

    // Rectangle
    const halfW = shape.w / 2;
    const halfH = shape.h / 2;

    const absDX = Math.abs(dx);
    const absDY = Math.abs(dy);

    let scale = halfW / absDX;
    if (absDY * scale > halfH)
        scale = halfH / absDY;

    return {
        x: cx + dx * scale,
        y: cy + dy * scale
    };
}

// return actual start/end points for an edge (matches drawArrow)
function getEdgePoints(edge) {
  const from = edge.from;
  const to = edge.to;

  const cx1 = from.type === "rectangle" ? from.x + from.w / 2 : from.x;
  const cy1 = from.type === "rectangle" ? from.y + from.h / 2 : from.y;

  const cx2 = to.type === "rectangle" ? to.x + to.w / 2 : to.x;
  const cy2 = to.type === "rectangle" ? to.y + to.h / 2 : to.y;

  const start = getBorderPoint(from, cx2, cy2); // uses your existing function
  const end = getBorderPoint(to, cx1, cy1);

  return { x1: start.x, y1: start.y, x2: end.x, y2: end.y };
}

// detect if a dbl-click hits an edge
// point-to-segment distance check (keeps threshold adjustable)
function isPointNearLine(px, py, x1, y1, x2, y2, threshold = 8) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;

  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  if (lenSq !== 0) param = dot / lenSq;

  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }

  const dx = px - xx;
  const dy = py - yy;
  return (dx * dx + dy * dy) <= threshold * threshold;
}

// Add the panel opener for edges
function openPanelForEdge(edge) {
  // Mark the "selected" to be the edge (you can manage using the same `selected` variable or a dedicated selectedEdge)
  selected = edge;          // note: selected will now be an edge object ‚Äî your other code should handle this if needed
  // open the panel
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
  panel.style.display = 'flex';

  // If you want to show edge-specific info inside existing controls, populate them here:
  // e.g. reuse panelText for an edge label
  panelText.value = edge.label || ""; 
  panelTextSize.value = edge.textSize || 14;
  panelTextColor.value = edge.textColor || "#000000";

  // update UI to reflect an "edge" selection if desired (optional)
  // e.g. propType.value = 'edge';
}

/* -------------------------
   History (undo/redo)
   ------------------------- */
function pushHistory(){

  // Avoid recording identical states (common during dragging)
  const last = history[history.length - 1];
  const current = { shapes, edges };

  if (last && JSON.stringify(last) === JSON.stringify(current)) {
    return; // skip duplicate
  }
  
  history.push({
    shapes: deepClone(shapes),
	edges: deepClone(edges)
  });
  
  if(history.length > HISTORY_LIMIT)
    history.shift();
  
  redoStack = [];
}

function undo(){
  if (history.length === 0)
    return; // don't undo initial state
  
  // Move current ‚Üí redo stack
  redoStack.push({
    shapes: deepClone(shapes),
	edges: deepClone(edges)
  });
  
  const prev = history.pop();

  shapes = prev.shapes.map(s => reviveShape(s));
  edges  = prev.edges.map(e => reviveEdge(e));

  redraw();
}

function redo(){
  if (redoStack.length === 0)
    return;

  // Take next state
  const next = redoStack.pop();

  // Save current before moving forward
  history.push({
    shapes: deepClone(next.shapes),
    edges: deepClone(next.edges)
  });

  // Restore shapes & edges and revive classes
  shapes = next.shapes.map(s => reviveShape(s));
  edges  = next.edges.map(e => reviveEdge(e));

  redraw();
}

function reviveShape(obj) {
  return new Shape(obj.type, obj.x, obj.y, obj.w, obj.h, obj.opts);
}

function reviveEdge(obj) {
  return new Edge(obj.from, obj.to, obj.opts || {});
}

/* -------------------- Modal API Rest -------------------- */

// open modal
document.getElementById("apiRestBtn").addEventListener("click", () => {

  // expand the panel to the left
  panelExpanded = true;
  panel.classList.add("expanded");

  document.getElementById("apiModalContent").style.display = "block";
  //document.getElementById("apiModal").style.display = "flex";
});

// close modal
document.getElementById("apiClose").addEventListener("click", () => {
  document.getElementById("apiModalContent").style.display = "none";
});

// send API request
document.getElementById("apiSendBtn").addEventListener("click", async () => {
  const method = document.getElementById("apiMethod").value;
  const url = document.getElementById("apiUrl").value;
  const body = document.getElementById("apiBody").value.trim();
  const resBox = document.getElementById("apiResponse");

  resBox.textContent = "Loading...";

  try {
    const options = { method };

    if (method !== "GET" && body.length > 0) {
      options.headers = { "Content-Type": "application/json" };
      options.body = body;
    }

    const res = await fetch(url, options);
    const text = await res.text();

    try {
      resBox.textContent = JSON.stringify(JSON.parse(text), null, 2);
    } catch {
      resBox.textContent = text;
    }

  } catch (err) {
    resBox.textContent = "Error:\n" + err;
  }
});

</script>
</body>
</html>
