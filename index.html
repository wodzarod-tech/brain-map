<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Shape Drawer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
	--toolbar-h:60px;
	--panel-w:340px;
  }
  
  body {
	margin:0;
	font-family:system-ui,Segoe UI,Roboto,Arial;
	user-select:none;
	-webkit-user-select:none;
  }
  
  #toolbar {
    height:var(--toolbar-h);
    display:flex;
    gap:10px;
    align-items:center;
    padding:8px;
    background:#f4f4f4;
    box-sizing:border-box;
	justify-content: space-between;
  }
  
  #toolbar > * { font-size:14px; }
  
  .left-tools {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .right-tools {
    margin-left: auto;         /* pushes to the right */
    display: flex;
    gap: 10px;
    align-items: center;
  }

  canvas {
    display:block;
	width:100vw;
	height:calc(100vh - var(--toolbar-h));
	background:#fff; cursor:crosshair;
  }
  
  button {
	padding:6px 10px;
	border-radius:6px;
	border:1px solid #bbb;
	background:#fff;
	cursor:pointer;
  }
  
  input[type="number"] { width:80px; }
  
  label {
	display:flex;
	align-items:center;
	gap:6px;
  }

  /* Slide-in panel (Option C) */
  #panel {
    position: fixed;
    right: 0;
    top: 0;
    width: var(--panel-w);
    height: 100vh;
    background: #ffffff;
    border-left: 1px solid #e3e3e3;
    box-shadow: -18px 0 40px rgba(10,10,10,0.06);
    transform: translateX(100%); /* animation */
    transition: transform 280ms cubic-bezier(.2,.8,.2,1); /* animation */
    z-index: 120;
    padding: 16px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  #panel.open { 
    transform: translateX(0); /* animation */
  }

  #panel header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
  }
  
  #panel h3 { 
	margin:0;
	font-size:16px
  }
  
  #panel .row {
	display:flex;
	gap:8px;
	align-items:center;
	margin-top:6px;
  }
  
  #panel label {
	width:120px;
	font-size:13px;
	color:#333;
  }
  
  #panel input[type="text"], #panel input[type="number"], #panel select {
    width: calc(100% - 120px);
    padding:6px 8px;
    border:1px solid #ddd;
    border-radius:6px;
    font-size:13px;
  }
  
  #panel input[type="color"] { 
	width:48px;
	height:32px;
	padding:0;
	border:0;
	background:transparent;
  }
  
  #panel .footer {
	margin-top:auto; /* pushes footer to bottom */
	display:flex;
	justify-content: flex-end;   /* pushes content to the right */
	gap:8px;
  }
  
  #panelClose {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 18px;
    height: 18px;
    font-size: 12px;
    line-height: 18px;
    padding: 0;
    border: none;
    border-radius: 4px;
    background: #ff9999; /* red */
    cursor: pointer;
  }

  #panelClose:hover {
    background: #e53939; /* darker red */
  }

  .muted { 
	color:#666;
	font-size:12px;
  }

  @media (max-width: 900px) { :root { --panel-w: 300px; } }
  
  #textEditor {
    background: transparent;
    outline: none;
    border: none;
	text-align: center;
	padding-top: 30%;
  }
  
  .label-line {
    display: inline-block;
	padding-bottom: 4px;
	border-bottom: 2px solid #000;
	font-weight: bold;
  }
  
  .icon-btn {
    background: #f3f3f3;
    border: 1px solid #ccc;
    padding: 6px;
    border-radius: 6px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  .icon-btn svg {
    fill: #333;
  }

  .icon-btn.active {
    background: #007bff;
    border-color: #006be6;
  }

  .icon-btn.active svg {
    fill: white;
  }
  
  /* for tabs **/
  #panelTabs {
    display: flex;
    border-bottom: 1px solid #ddd;
    margin-bottom: 10px;
  }

  #panelTabs .tab {
    flex: 1;
    padding: 10px;
    background: #f4f4f4;
    border: none;
    cursor: pointer;
    font-size: 14px;
    color: #444;
  }

  #panelTabs .tab.active {
    background: #ffffff;
    border-bottom: 2px solid #007bff;
    color: #007bff;
    font-weight: bold;
  }

  .tabContent { display: none; }
  .tabContent.active { display: block; }
  
  /* Function tab: add textboxes*/
  .textbox {
    width: 100%;
	height: 80px;
	padding: 6px;
	border: 1px solid #ccc;
	border-radius: 6px;
	resize: vertical;
	font-size: 13px;
	box-sizing: border-box;
  }

  /* delete textboxes */
  .textbox-wrapper {
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 6px;
    margin-bottom: 8px;
    background: #fafafa;
  }
  
  .textbox-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    padding: 4px;
    font-size: 13px;
    font-weight: bold;
  }

  .textbox-body {
    margin-top: 6px;
    display: block; /* collapsible */
  }

  .textbox {
    width: 100%;
    height: 80px;
    padding: 6px;
    border: 1px solid #ccc;
    border-radius: 6px;
    resize: vertical;
    font-size: 13px;
    box-sizing: border-box;
  }

  .collapseBtn {
    font-size: 14px;
    cursor: pointer;
    background: none;
    border: none;
    padding: 0 4px;
  }

  /* delete button */
    .deleteTextboxBtn {
    background: #e57373;
    border: none;
    color: white;
    font-size: 12px;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    cursor: pointer;
    text-align: center;
    padding: 0;
    margin-left: 6px;
  }

  .deleteTextboxBtn:hover {
    background: #d32f2f;   /* slightly stronger tone */
  }

  .textbox-header-left {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  /* Function section / search button */
  .service-btn {
    padding:18px 0;
    border-radius:10px;
    border:1px solid #ccc;
    background:#fafafa;
    cursor:pointer;
    font-size:14px;
    transition:0.2s;
  }

  .service-btn:hover {
    background:#eaeaea;
  }
  
  /* Left tools */
  .left-tools {
    display: flex;
    align-items: center;
    gap: 4px;
	margin-right: auto;   /* keeps them stuck to the left */
  }

  /* text button */
  .icon-txt-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 32px;       /* or whatever size you want */
    height: 32px;
    font-size: 18px;
    line-height: 1;
    padding: 0;
  }

  .icon-txt-btn:hover {
    background: #e8e8e8;
  }
 
 .icon-txt-btn.active {
    background-color: #0078ff;
    color: white;
  }

</style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- for insert text into a shape -->
  <textarea id="textEditor"
		    style="position:absolute; display:none; resize:none;
				   padding:4px; font-size:16px; 
				   border:1px solid #333; outline:none;">
  </textarea>

  <!-- Slide-in Panel for Shape Properties -->
  <div id="panel" aria-hidden="true">
	
    <button id="panelClose" title="Close panel">‚úï</button>

	<div id="toolbar">
	  
	  <!-- Left side -->
	  <div class="left-tools">
		<label>Shape:
		  <select id="shapeType">
			<option value="circle">Circle</option>
			<option value="rectangle">Rectangle</option>
		  </select>
		</label>
		
		<button id="insertTextBtn" class="icon-txt-btn" title="Insert Text">‚úé</button>
	  </div>

	  <!-- Right side -->
	  <div class="right-tools">
		<button id="toggleGridBtn" class="icon-btn" title="Toggle Grid">
		  <svg viewBox="0 0 24 24" width="20" height="20">
			<path d="M3 3h4v4H3V3zm7 0h4v4h-4V3zm7 0h4v4h-4V3zM3 10h4v4H3v-4zm7 0h4v4h-4v-4zm7 0h4v4h-4v-4zM3 17h4v4H3v-4zm7 0h4v4h-4v-4zm7 0h4v4h-4v-4z"/>
		  </svg>
		</button>

		<button id="clearBtn" class="small" title="Clear">üóëÔ∏è</button>
		<button id="deleteBtn" style="display:none">Delete Selected</button>
	  </div>
	</div>

    <!-- Tabs Header -->
    <div id="panelTabs">
      <button class="tab active" data-tab="styleTab">Design</button>
      <button class="tab" data-tab="textTab">Function</button>
    </div>
  
    <!-- Tab Design -->
    <div id="styleTab" class="tabContent active">
  
		<header>
		  <h3>Shape Properties</h3>
		</header>

		<div class="row">
		  <label class="label-line">Shape</label>
		</div>

		<div class="row">
		  <label>Type</label>
			<select id="propType" disabled>
			  <option value="rectangle">Rectangle</option>
			  <option value="circle">Circle</option>
			</select>
		</div>

		<div class="row">
		  <label>Fill</label>
		  <input id="propFill" type="color">
		</div>

		<div class="row">
		  <label>Border</label>
		  <select id="propBorder">
	   	    <option value="none">None</option>
			<option value="solid">Solid</option>
			<option value="dashed">Dashed</option>
			<option value="bold">Bold</option>
		  </select>
		</div>

		<div class="row">
		  <label>Thickness</label>
		  <input id="propThickness" type="number" min="1" max="20" step="1">
		</div>

		<div class="row">
		  <label>Opacity</label>
		  <input id="propOpacity" type="range" min="0" max="1" step="0.05">
		  <span id="propOpacityVal" class="muted" style="min-width:40px;text-align:right;"></span>
		</div>

		<div class="row">
		  <label>Rounded</label>
		  <input id="propRounded" type="checkbox" title="Rectangle rounded">
		</div>

		<div class="row">
		  <label>X</label>
		  <input id="propX" type="number" step="1">
		</div>

		<div class="row">
		  <label>Y</label>
		  <input id="propY" type="number" step="1">
		</div>

		<div class="row" id="sizeRow">
		  <label>W</label>
		  <input id="propW" type="number" step="1">
		</div>

		<div class="row" id="sizeRowH">
		  <label>H / R</label>
		  <input id="propH" type="number" step="1">
		</div>

		<div class="row">
			<label class="label-line">Text</label>
		</div>
	  
		<div class="row">
		  <label>Text</label>
		  <input id="panelText" type="text" placeholder="shape text">
		</div>

		<div class="row">
		  <label>Font size</label>
		  <input id="panelTextSize" type="number" min="8" max="72" value="16">
		</div>

		<div class="row">
		  <label>Text color</label>
		  <input id="panelTextColor" type="color" value="#000000">
		</div>

		<div class="row">
		  <label>Text Position:</label>
		  <select id="textPosition">
			<option value="center">Center</option>
			<option value="top">Top</option>
			<option value="bottom">Bottom</option>
			<option value="left">Left</option>
			<option value="right">Right</option>
		  </select>
		</div>
	</div>

	<!-- Tab Functions -->
	<div id="textTab" class="tabContent">
	
	  <!-- Notes: collapsible wrapper -->
	  <div id="infoSection" style="
        border:1px solid #ccc;
        border-radius:6px;
        overflow:hidden;
        margin-bottom:10px;
      ">
  
        <!-- header collapsible -->
        <div id="infoHeader" style="
          display:flex;
          align-items:center;
          justify-content:space-between;
          padding:6px 10px;
          background:#f1f1f1;
          cursor:pointer;
        ">
          
          <div style="display:flex; align-items:center; gap:8px;">
			<span id="infoToggle" style="font-size:13px; opacity:0.7;">‚ñº</span>
			<h3 style="margin:0; font-size:16px;">Notes</h3>
		  </div>
  		  <button id="addTextboxBtn" class="icon-btn" title="Add Textbox">Ôºã</button>
        </div>
	
	    <!-- content -->
        <div id="infoContent" style="padding:10px; display:block;">
          <header style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
          </header>

	      <div id="textList" style="margin-top:12px; display:flex; flex-direction:column; gap:10px;"></div>
      </div>
	</div>
	
	<!-- Services: collapsible wrapper -->
	<div id="servicesSection" style="
        border:1px solid #ccc;
        border-radius:6px;
        overflow:hidden;
        margin-bottom:10px;
      ">
  
        <!-- header collapsible -->
        <div id="servicesHeader" style="
          display:flex;
          align-items:center;
          justify-content:space-between;
          padding:6px 10px;
          background:#f1f1f1;
          cursor:pointer;
        ">
          
          <div style="display:flex; align-items:center; gap:8px;">
			<span id="servicesToggle" style="font-size:13px; opacity:0.7;">‚ñº</span>
			<h3 style="margin:0; font-size:16px;">Services</h3>
		  </div>
        </div>
	
	    <!-- content -->
        <div id="servicesContent" style="padding:10px; display:block;">
          <header style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
		  
		  <!-- Textbox for searching -->
          <input id="servicesInput" 
             type="text" 
             placeholder="Search services..." 
             style="
               flex:1;
               padding:6px 8px;
               border:1px solid #ccc;
               border-radius:4px;
               font-size:14px;
             ">

          <!-- Search button -->
          <button id="servicesSearchBtn" class="icon-btn" title="Search" style="
               padding:6px;
               border-radius:6px;
               border:1px solid #ccc;
               background:#f3f3f3;
               cursor:pointer;
          ">
            <svg viewBox="0 0 24 24" width="18" height="18">
            <path d="M15.5 14h-.8l-.3-.3a6 6 0 10-.7.7l.3.3v.8l5 5 1.5-1.5-5-5zm-6 0A4.5 4.5 0 1114 9.5 4.5 4.5 0 019.5 14z"/>
            </svg>
          </button>
	  
          </header>
		  
		  <!-- Search buttonz -->
		  <div id="servicesGrid" style="
		    display:grid;
			grid-template-columns: repeat(4, 1fr);
			gap:10px;
			margin-top:10px;
		  ">

		  <!-- 12 buttons (4 √ó 3) -->
		  <!-- row 1 -->
		  <button class="service-btn" style="display:flex; align-items:center; justify-content:center;" title="Postman">
		    <img src="images/postman-logo-orange-stacked.svg"
			     alt="Postman"
			     style="width:50px; height:50px;">
		  </button>
		  
		  <button class="service-btn" style="display:flex; align-items:center; justify-content:center;" title="API Rest">
		    <img src="images/rest-api-icon.svg"
			     alt="API Rest"
			     style="width:50px; height:50px;">
		  </button>
		  
		  <button class="service-btn" style="display:flex; align-items:center; justify-content:center;" title="Email">
		    <img src="images/email.svg"
			     alt="Email"
			     style="width:50px; height:50px;">
		  </button>

		  <button class="service-btn" style="display:flex; align-items:center; justify-content:center;" title="Twitter">
		    <img src="images/twitter.svg"
			     alt="Twitter"
			     style="width:50px; height:50px;">
		  </button>

		  <!-- row 2 -->
		  <button class="service-btn">E</button>
		  <button class="service-btn">F</button>
		  <button class="service-btn">G</button>
		  <button class="service-btn">H</button>

		  <!-- row 3 -->
		  <button class="service-btn">I</button>
		  <button class="service-btn">J</button>
		  <button class="service-btn">K</button>
		  <button class="service-btn">L</button>
		  </div>
        </div>
	</div>
	
    <div class="footer">
      <button id="propApply">Apply</button>
      <button id="propReset">Reset</button>
    </div>
  </div>

<script>
/* -------------------- Setup & State -------------------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const toolbar = document.getElementById('toolbar');
const shapeType = document.getElementById('shapeType');

const clearBtn = document.getElementById('clearBtn');
const deleteBtn = document.getElementById('deleteBtn');

const panel = document.getElementById('panel');
const panelClose = document.getElementById('panelClose');
const propType = document.getElementById('propType');
const propFill = document.getElementById('propFill');
const propBorder = document.getElementById('propBorder');
const propThickness = document.getElementById('propThickness');
const propOpacity = document.getElementById('propOpacity');
const propOpacityVal = document.getElementById('propOpacityVal');
const propRounded = document.getElementById('propRounded');
const propX = document.getElementById('propX');
const propY = document.getElementById('propY');
const propW = document.getElementById('propW');
const propH = document.getElementById('propH');
const propApply = document.getElementById('propApply');
const propReset = document.getElementById('propReset');

const panelText = document.getElementById('panelText');
const panelTextSize = document.getElementById('panelTextSize');
const panelTextColor = document.getElementById('panelTextColor');

const textEditor = document.getElementById("textEditor");

// for Function tab
const textList = document.getElementById("textList");
const addTextboxBtn = document.getElementById("addTextboxBtn");

// for insert text
const insertTextBtn = document.getElementById("insertTextBtn");
let insertingText = false;

// main variables
let shapes = [];         // list of drawn shapes
let selected = null;     // shape currently selected
let tempShape = null;    // shape preview while drawing

// interaction flags
let isDrawing = false; // disable drawing when clicking
let isDragging = false;
let isResizing = false;

let activeHandle = null;

// pointer start
let startX = 0, startY = 0;
let dragOffsetX = 0, dragOffsetY = 0;

let editingShape = null;

let showGrid = true; // grid enabled

// connect nodes with edge
//let connecting = false; 
//let sourceNode = null; // the node where the user started dragging from
let edges = []; // { from: shapeObject, to: shapeObject }
let pendingConnection = null; // when first shape selected
let justCreatedShape = null; // for move shape in the first attempt
let shapeIsMoving = false;

// collapse/expand behabior
const infoHeader = document.getElementById("infoHeader");
const infoToggle = document.getElementById("infoToggle");
const infoContent = document.getElementById("infoContent");

/* -------------------- Canvas size -------------------- */
function setCanvasSizeCSS() {
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = (window.innerHeight - toolbar.offsetHeight) + 'px';
  fitCanvas();
}

// canvas auto-scaling
function fitCanvas() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  redraw();
}

window.addEventListener('resize', setCanvasSizeCSS);
setCanvasSizeCSS();

// grid toggle
document.getElementById("toggleGridBtn").addEventListener("click", () => {
  showGrid = !showGrid;
  
  if (showGrid) {
    toggleGridBtn.classList.add("active");
  } else {
    toggleGridBtn.classList.remove("active");
  }
  
  redraw();
});

// initial redraw
redraw();

/* -------------------- Shape Class -------------------- */
/*
1. each shape stores:
Type: "rectangle" or "circle"
Position: x, y
Dimensions: w, h
Rounded corners (rectangle only)
Fill, stroke, opacity
Text & text style

2. methods:
draw(): draws shape on canvas
drawOutline(): red dashed selection outline
drawHandles(): corner handles for resizing
contains(px,py): check if clicked
handleAt(px,py): check if touching a handle
*/
class Shape {
  constructor(type, x, y, w, h, opts = {}) {
    this.type = type;
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.rounded = !!opts.rounded;
    this.radius = (this.rounded && type === 'rectangle') ? Math.max(0, Math.min(Math.abs(w), Math.abs(h)) * 0.1) : 0;

    this.opts = {
      border: opts.border || 'none',
      fill: opts.fill || '#ffffff',
      thickness: opts.thickness || 2,
      opacity: typeof opts.opacity === 'number' ? opts.opacity : 1
    };

    // Text properties
    this.text = opts.text || "";
    this.textSize = opts.textSize || 16;
    this.textColor = opts.textColor || "#000000";
	this.textPosition = opts.textPosition || "center"; 
  }

  draw(ctx, highlight=false) {
  debugger;
    ctx.save();
    ctx.globalAlpha = this.opts.opacity;
	
	const isNoBorder = this.opts.border === "none";
	
    ctx.fillStyle = this.opts.fill;
	
	if (!isNoBorder) {
      ctx.strokeStyle = 'black';
      ctx.lineWidth = this.opts.border === 'bold' ? this.opts.thickness * 3 : this.opts.thickness;
    
	  ctx.setLineDash(this.opts.border === 'dashed' ? [6,4] : []);
	} else {
      // No border ‚Üí clear dash + no stroke
      ctx.setLineDash([]);
    }

    // draw edges first or last (your choice)
    for (const e of edges) {
      drawArrow(e.from, e.to);
    }

    // draw shape
    if (this.type === 'rectangle') {
      drawRoundedOrPlainRect(ctx, this.x, this.y, this.w, this.h, this.rounded ? this.radius : 0);
	  
      ctx.fill();

      // stroke only if border is NOT none
      if (!isNoBorder)
	    ctx.stroke();
		
    } else { // circle
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      ctx.beginPath();
      ctx.arc(this.x, this.y, r, 0, Math.PI*2);
      ctx.fill();
	  
      if (!isNoBorder)
	    ctx.stroke();
    }

    if (highlight && !shapeIsMoving) {
      this.drawOutline(ctx);
      this.drawHandles(ctx); // draw squares corners
    }
		
    ctx.restore();
  }

  // draw a pixel at the center of a shape
  drawCenterPixel(ctx) {
  debugger;
  let cx;
  let cy;
    if (this.type === "rectangle") {
        cx = this.x + this.w / 2,
        cy = this.y + this.h / 2
    } else { 
      // circle ‚Äî your shape.x and shape.y ARE already the center
        cx = this.x + this.w / 2,
		cy = this.y + this.h / 2
    }
	debugger;
	ctx.fillStyle = "red";        // or any color
	ctx.fillRect(cx, cy, 7, 7);  // 1 single pixel
  }

  drawOutline(ctx) {
    ctx.save();
    ctx.setLineDash([4,4]);
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    if (this.type === 'rectangle') {
      ctx.strokeRect(this.x - 6, this.y - 6, this.w + 12, this.h + 12);
    } else {
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      ctx.beginPath();
      ctx.arc(this.x, this.y, r + 6, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  getHandles() {
    if (this.type === 'rectangle') {
      return [
        {name:'tl', x:this.x, y:this.y},
        {name:'tr', x:this.x + this.w, y:this.y},
        {name:'bl', x:this.x, y:this.y + this.h},
        {name:'br', x:this.x + this.w, y:this.y + this.h},
      ];
    } else {
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      return [
        {name:'tl', x:this.x - r, y:this.y - r},
        {name:'tr', x:this.x + r, y:this.y - r},
        {name:'bl', x:this.x - r, y:this.y + r},
        {name:'br', x:this.x + r, y:this.y + r},
      ];
    }
  }

  drawHandles(ctx) {
    const hs = this.getHandles();
    ctx.save();
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    hs.forEach(h => {
      ctx.beginPath();
      ctx.rect(h.x - 6, h.y - 6, 12, 12);
      ctx.fill();
      ctx.stroke();
    });
    ctx.restore();
  }

  contains(px,py) {
    if (this.type === 'rectangle') {
      const x0 = Math.min(this.x, this.x + this.w);
      const x1 = Math.max(this.x, this.x + this.w);
      const y0 = Math.min(this.y, this.y + this.h);
      const y1 = Math.max(this.y, this.y + this.h);
      return px >= x0 && px <= x1 && py >= y0 && py <= y1;
    } else {
      const r = Math.max(0, Math.sqrt(this.w*this.w + this.h*this.h));
      const dx = px - this.x;
      const dy = py - this.y;
      return dx*dx + dy*dy <= r*r;
    }
  }

  handleAt(px,py) {
    const hs = this.getHandles();
    for (const h of hs) {
      if (px >= h.x - 6 && px <= h.x + 6 && py >= h.y - 6 && py <= h.y + 6) return h.name;
    }
    return null;
  }
}

/* -------------------- Panel Control -------------------- */
/*
used when selecting a shape

Panel fields are updated with:
	fill color
	border style
	opacity
	text fields
	x/y/w/h
*/
function openPanelForShape(shape) {
  if (!shape) return;
  
  selected = shape;

  syncPanelToShape();
  
  // show toolbar text controls if shape has text (we show them always when selected)
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
  
  // ensure panel is visible (force reflow in odd cases)
  panel.style.display = 'flex';
}

function closePanel() {
  panel.classList.remove('open');
  panel.setAttribute('aria-hidden', 'true');
}

// syncing the Panel
function syncPanelToShape() {
  if (!selected) return;
  
  propType.value = selected.type;
  propFill.value = selected.opts.fill;
  propBorder.value = selected.opts.border;
  propThickness.value = selected.opts.thickness;
  propOpacity.value = selected.opts.opacity;
  propOpacityVal.innerText = selected.opts.opacity.toFixed(2);
  propRounded.checked = !!selected.rounded;
  propX.value = Math.round(selected.x);
  propY.value = Math.round(selected.y);

  // for rectangle
  if (selected.type === 'rectangle') {
    propW.value = Math.round(selected.w);
    propH.value = Math.round(selected.h);
    document.getElementById('sizeRow').style.display = '';
    document.getElementById('sizeRowH').style.display = '';
  } else { // for circle
    const r = Math.round(Math.max(0, Math.sqrt(selected.w*selected.w + selected.h*selected.h)));
    propW.value = r;
    propH.value = r;
    document.getElementById('sizeRow').style.display = '';
    document.getElementById('sizeRowH').style.display = '';
  }

  // text fields
  panelText.value = selected.text || "";
  panelTextSize.value = selected.textSize || 16;
  panelTextColor.value = selected.textColor || "#000000";
}

// apply shape properties
function applyPanelToShape(live = true) {
  if (!selected) return;
  selected.opts.fill = propFill.value;
  selected.opts.border = propBorder.value;
  selected.opts.thickness = +propThickness.value;
  selected.opts.opacity = +propOpacity.value;

  if (selected.type === 'rectangle') {
    selected.rounded = propRounded.checked;
    if (selected.rounded) selected.radius = Math.max(0, Math.min(Math.abs(+propW.value), Math.abs(+propH.value)) * 0.1);
    selected.x = +propX.value;
    selected.y = +propY.value;
    selected.w = +propW.value;
    selected.h = +propH.value;
  } else {
    const r = Math.max(0, +propW.value || +propH.value);
    selected.w = r; selected.h = r;
    selected.x = +propX.value;
    selected.y = +propY.value;
  }

  // text
  selected.text = panelText.value;
  selected.textSize = +panelTextSize.value;
  selected.textColor = panelTextColor.value;

  if (live) redraw();
}

// for switching tabs
document.querySelectorAll("#panelTabs .tab").forEach(btn => {
  btn.addEventListener("click", () => {
    
  document.querySelectorAll("#panelTabs .tab")
	.forEach(t => t.classList.remove("active"));
  
  btn.classList.add("active");

  const tabId = btn.dataset.tab;

  document.querySelectorAll(".tabContent")
	.forEach(c => c.classList.remove("active"));

  document.getElementById(tabId).classList.add("active");
  });
});

// Function tab, to add textboxes with delete button each one
addTextboxBtn.addEventListener("click", (e) => {
  e.stopPropagation(); // prevents collapsing

  // wrapper
  const wrapper = document.createElement("div");
  wrapper.className = "textbox-wrapper";
  
  // header
  const header = document.createElement("div");
  header.className = "textbox-header";
  
  const headerLeft = document.createElement("div");
  headerLeft.className = "textbox-header-left";
  
  // collapse button
  const collapseBtn = document.createElement("button");
  collapseBtn.className = "collapseBtn";
  collapseBtn.textContent = "‚ñº";
  collapseBtn.style.marginRight = "6px";
  
  // title
  const title = document.createElement("span");
  title.contentEditable = "true";
  title.textContent = "Title";
  title.style.outline = "none";      // removes border when editing
  title.style.cursor = "text";
  title.style.whiteSpace = "nowrap";
  title.style.overflow = "hidden";
  title.style.textOverflow = "ellipsis";
  title.spellcheck = false;          // optional
  
  // prevent title multiline
  title.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      title.blur();
    }
  });

  // limit to 30 characters
  title.addEventListener("input", () => {
    if (title.textContent.length > 30) {
      title.textContent = title.textContent.slice(0, 30);

    // move caret to end
    const range = document.createRange();
    const sel = window.getSelection();
    range.selectNodeContents(title);
    range.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range);
    }
  });

  // don't collapse section when clicking title
  title.addEventListener("click", (e) => {
    e.stopPropagation();
  });

  // delete button
  const removeBtn = document.createElement("button");
  removeBtn.className = "deleteTextboxBtn";
  removeBtn.textContent = "√ó";
  removeBtn.title = "Remove textbox";
  
  // body
  const body = document.createElement("div");
  body.className = "textbox-body";
  
  // create textbox
  const box = document.createElement("textarea");
  box.className = "textbox";
  box.placeholder = "Write here...";

  body.appendChild(box);

  // collapse/expand handling
  collapseBtn.addEventListener("click", (ev) => {
    ev.stopPropagation();
    
	if (body.style.display === "none") {
      body.style.display = "block";
      collapseBtn.textContent = "‚ñº";
    } else {
      body.style.display = "none";
      collapseBtn.textContent = "‚ñ∫";
    }
  });

  // remove textbox
  removeBtn.addEventListener("click", () => wrapper.remove());

  // order
  headerLeft.appendChild(collapseBtn);
  headerLeft.appendChild(title);
  
  header.appendChild(headerLeft); // add header
  header.appendChild(removeBtn); // add delete button

  wrapper.appendChild(header);
  wrapper.appendChild(body); // add textbox

  textList.appendChild(wrapper);
});

// Activate text insert mode
insertTextBtn.addEventListener("click", () => {
  insertingText = !insertingText;
  insertTextBtn.classList.toggle("active", insertingText);
});

// Function / Docs: collapse/expand behabior
infoHeader.addEventListener("click", () => {
  const isOpen = infoContent.style.display !== "none";

  if (isOpen) {
    infoContent.style.display = "none";
    infoToggle.textContent = "‚ñ∫"; // collapsed
  } else {
    infoContent.style.display = "block";
    infoToggle.textContent = "‚ñº"; // expanded
  }
});

shapeType.addEventListener("click", () => {
    insertingText = false;
	insertTextBtn.classList.remove("active");
});

// live updates from panel
propFill.addEventListener('input', () => { if(selected){ selected.opts.fill = propFill.value; redraw(); }});
propBorder.addEventListener('change', () => { if(selected){ selected.opts.border = propBorder.value; redraw(); }});
propThickness.addEventListener('input', () => { if(selected){ selected.opts.thickness = +propThickness.value; redraw(); }});
propOpacity.addEventListener('input', () => { if(selected){ selected.opts.opacity = +propOpacity.value; propOpacityVal.innerText = (+propOpacity.value).toFixed(2); redraw(); }});

// rounded corners
propRounded.addEventListener('change', () => { 
	if(selected && selected.type === 'rectangle'){ 
		selected.rounded = propRounded.checked; 
		if(selected.rounded) 
			selected.radius = Math.max(0, Math.min(Math.abs(selected.w), Math.abs(selected.h)) * 0.1); 
			redraw(); 
	}
});

[propX, propY].forEach(inp => inp.addEventListener('input', () => { if(selected){ selected.x = +propX.value; selected.y = +propY.value; redraw(); }}));
propW.addEventListener('input', () => { if(!selected) return; if(selected.type === 'rectangle'){ selected.w = +propW.value; if(selected.rounded) selected.radius = Math.max(0, Math.min(Math.abs(selected.w), Math.abs(selected.h)) * 0.1); } else { selected.w = +propW.value; selected.h = +propW.value; } redraw(); });
propH.addEventListener('input', () => { if(!selected) return; if(selected.type === 'rectangle'){ selected.h = +propH.value; if(selected.rounded) selected.radius = Math.max(0, Math.min(Math.abs(selected.w), Math.abs(selected.h)) * 0.1); } else { const r = +propH.value; selected.w = r; selected.h = r; } redraw(); });

propApply.addEventListener('click', () => { applyPanelToShape(false); closePanel(); });
propReset.addEventListener('click', () => { syncPanelToShape(); });

panelClose.addEventListener('click', closePanel);

/* -------------------- Pointer Events -------------------- */
// when mouse click
canvas.addEventListener('pointerdown', (ev) => {
  ev.preventDefault();

  canvas.setPointerCapture(ev.pointerId);
  
  const pos = screenToCanvas(ev); // autoscaling

  activeHandle = null;
  isResizing = false;
  shapeIsMoving = false;

  // -----------------------------
  // 1. HANDLE RESIZE HANDLES
  // -----------------------------
  // check if click hits a resize handle -> start resizing
  if (selected) {
    const hn = selected.handleAt(pos.x, pos.y);
    if (hn) {
      activeHandle = hn;
      isResizing = true;
      startX = pos.x;
	  startY = pos.y;
      return;
    }
  }

  //console.log("selected",selected);
  //console.log("isResizing",isResizing);
  //console.log("activeHandle",activeHandle);
  
  // -----------------------------
  // 2. HIT TEST SHAPES
  // -----------------------------
  // check if click hits a shape ‚Üí select + drag
  selected = null;
  
  for (let i = shapes.length - 1; i >= 0; i--) {
    if (shapes[i].contains(pos.x, pos.y)) {
      const hit = shapes[i];
	  selected = hit;
	  //selected = shapes[i];
	  
	  // ----------------------------------------------------------
      // SPECIAL CASE: FIRST CLICK AFTER CREATED A SHAPE ‚Üí MOVE IT
      // ----------------------------------------------------------
	  /*if (hit === justCreatedShape) {
        selected = hit;
        justCreatedShape = null;

        isDragging = true;
        dragOffsetX = pos.x - selected.x;
        dragOffsetY = pos.y - selected.y;
        redraw();
        return;
      }*/
	  
      // ----------------------------------------------------------
      // CONNECTION MODE
      // ----------------------------------------------------------
	  // for connection shapes
	  if (pendingConnection === null) {
        // first click ‚Üí start connection
        pendingConnection = hit;
        //selected = hit;
        //redraw();
        //return;
      } else if (pendingConnection && hit !== pendingConnection) {
        // second click ‚Üí complete arrow
        edges.push({
          from: pendingConnection,
          to: hit
        });

        pendingConnection = null;
        //selected = hit;
        //redraw();
        //return;
      }

      // ----------------------------------------------------------
      // NORMAL CLICK: SELECT + DRAG
      // ----------------------------------------------------------
      justCreatedShape = null; // reset if it was set
	  //mouseDownInsideShape = true;
		
	  // only reached if NOT in connection mode
      isDragging = true;
      dragOffsetX = pos.x - selected.x;
      dragOffsetY = pos.y - selected.y;
	  
      // open panel for this shape
      //openPanelForShape(selected);
      redraw();
      return;
    }
  }
  
  // clicking empty canvas cancels connection mode
  pendingConnection = null;

  // -----------------------------
  // 3. CREATE NEW SHAPE
  // -----------------------------
  // if click did NOT hit any shape ‚Üí create a new shape (circle by default) instantly
  if (!selected) {
    // snap-to-grid
    let x = pos.x, y = pos.y;
    
	if (showGrid) {
      x = snapToGrid(x);
      y = snapToGrid(y);
    }
	
	//let newShape;
	
	// TEXT INSERT MODE: for inserting text on canvas
	if(insertingText) {
      const newShapeText = new Shape(
      'rectangle',       	 // rectangle
      x,            	 	 // center adjust
      y,
      100,                    // default width
      50,                    // default height
      {
        fill: "transparent",
        border: "none",
        thickness: 2,
        opacity: 1,
        rounded: false,
		text: "Text"
      });
	  
	  shapes.push(newShapeText);
      justCreatedShape = newShapeText; // for move shape in the first attempt
      selected = null; // do not auto-select (resizing) the new shape
      redraw();
      //return;
	}
	// NORMAL SHAPE MODE
	else {
	  const newShape = new Shape(
      shapeType.value,       // rectangle or circle
      x,            	 	 // center adjust
      y,
      shapeType.value == 'rectangle' ? 100 : 10, // default width
      shapeType.value == 'rectangle' ? 50 : 10,  // default height
      {
        fill: "#ffffff",
        border: "solid",
        thickness: 2,
        opacity: 1,
        rounded: false
      });
	  
	  shapes.push(newShape);
      justCreatedShape = newShape;  // for move shape in the first attempt
	  selected = null; // do not auto-select (resizing) the new shape
	  //selected = newShape;
	  redraw();
	  return;   // stop normal drawing logic
	}

	//openPanelForShape(selected);
	redraw();
	return;   // stop normal drawing logic
  }

  // start drawing a new shape
  isDrawing = false; // disable drawing when clicking
  startX = pos.x;
  startY = pos.y;
  tempShape = null;
  
  // when starting to draw, close panel (avoid overlap)
  closePanel();
});

// when mouse is moving
canvas.addEventListener('pointermove', (ev) => {
  const pos = screenToCanvas(ev);
  
  // for resizing
  if (isResizing && selected && activeHandle) {
    resizeShape(selected, activeHandle, pos.x, pos.y);
    syncPanelToShape();
    redraw();
    return;
  }

  // for dragging
  if (isDragging && selected) {
    shapeIsMoving = true;
	
	pendingConnection = null; // cancel connection mode with arrow after moving a shape
	
    let newX = pos.x - dragOffsetX;
    let newY = pos.y - dragOffsetY;

    // snap-to-grid
    if (showGrid) {
      newX = snapToGrid(newX);
      newY = snapToGrid(newY);
    }

    selected.x = newX;
    selected.y = newY;
  
    syncPanelToShape();
    redraw();
    return;
  }

  // for drawing
  if (isDrawing) {
	// drawing a rectangle
    if (shapeType.value === 'rectangle') {
      const x = Math.min(startX, pos.x);
      const y = Math.min(startY, pos.y);
      const w = Math.abs(pos.x - startX);
      const h = Math.abs(pos.y - startY);
      tempShape = new Shape('rectangle', x, y, w, h, {
        //border: borderType.value,
        //fill: fillColor.value,
        //thickness: +thickness.value,
        //opacity: +opacity.value
        //rounded: willBeRounded
      });
    } else { // drawing a circle
      const dx = pos.x - startX;
      const dy = pos.y - startY;
      const r = Math.max(0, Math.sqrt(dx*dx + dy*dy));
      tempShape = new Shape('circle', startX, startY, r, r, {
        //border: borderType.value,
        //fill: fillColor.value,
        //thickness: +thickness.value,
        //opacity: +opacity.value
      });
    }
    redraw();
    return;
  }

  // update cursor
  let cursor = 'crosshair';
  if (selected) {
    if (selected.handleAt(pos.x, pos.y)) cursor = 'nwse-resize';
    else if (selected.contains(pos.x,pos.y)) cursor = 'grab';
  } else {
    for (let i = shapes.length - 1; i >= 0; i--) {
      if (shapes[i].contains(pos.x,pos.y)) { cursor = 'pointer'; break; }
    }
  }
  canvas.style.cursor = cursor;
});

// when mouse is up
canvas.addEventListener('pointerup', (ev) => {
  //debugger;
  ev.preventDefault();
  canvas.releasePointerCapture(ev.pointerId);
  const pos = screenToCanvas(ev);
  
  // If user clicked empty space ‚Üí cancel pending connection
  if (!selected) {
    pendingConnection = null;
  }

  // for resizing
  if (isResizing) {
    isResizing = false;
    activeHandle = null;
    syncPanelToShape();
    redraw();
    return;
  }

  // for dragging
  if (isDragging) {
    isDragging = false;
    syncPanelToShape();
    redraw();
    return;
  }

  // for drawing
  if (isDrawing && tempShape) {
    if ((tempShape.type === 'rectangle' && tempShape.w > 4 && tempShape.h > 4) ||
        (tempShape.type === 'circle' && Math.sqrt(tempShape.w*tempShape.w + tempShape.h*tempShape.h) > 4)) {

      shapes.push(tempShape);
      selected = tempShape;
	  
      // open panel for new shape
      //openPanelForShape(selected);
    }
    tempShape = null;
  }

  isDrawing = false;
  pendingConnection = null;
  redraw();
});

canvas.addEventListener('pointercancel', (ev) => {
  //debugger;
  if (isDrawing) { isDrawing = false; tempShape = null; redraw(); }
  if (isDragging) isDragging = false;
  if (isResizing) { isResizing = false; activeHandle = null; }
});

clearBtn.addEventListener('click', () => {
  shapes = [];
  selected = null;
  tempShape = null;
  closePanel();
  redraw();
});

deleteBtn.addEventListener('click', () => {
  if (selected) { 
    shapes = shapes.filter(s => s !== selected); 
	selected = null; 
	closePanel(); 
	redraw(); 
  }
});

// when change position of text in a shape
document.querySelector("#textPosition").addEventListener("change", (e) => {
  if (!selected) return;
    selected.textPosition = e.target.value;
  redraw();
});

// when press delete key to delete a shape
document.addEventListener('keydown', (e) => {
  if (e.key === 'Delete' && selected) {
    shapes = shapes.filter(s => s !== selected);
    selected = null; closePanel(); redraw();
  }
});

// deselect on canvas click when clicking empty area (and close panel)
// or when ending drawing a shape
canvas.addEventListener('click', (ev) => {
  const pos = screenToCanvas(ev);
  let hit = false;
  
  // If we are editing text, finish it when the user clicks the canvas
  if (editingShape) {
    finishInlineEdit();
  }
	
  for (let i = shapes.length - 1; i >= 0; i--) { if (shapes[i].contains(pos.x,pos.y)) { hit = true; break; } }
  if (!hit) { selected = null; closePanel(); redraw(); }
});

// ESC to cancel editing
document.addEventListener("keydown", (e) => {
    if (!editingShape) return; // no editor open -> do nothing

    if (e.key === "Escape") {
        finishInlineEdit();
    }
});

// when double-left click
canvas.addEventListener('dblclick', (ev) => {
  ev.preventDefault();
  const pos = screenToCanvas(ev);
  
  // find shape under double click
  //let hit = null;
  for (let i = shapes.length - 1; i >= 0; i--) {
    if (shapes[i].contains(pos.x, pos.y)){
	  selected = shapes[i];
	  //hit = shapes[i];
	  // open panel for this shape
	  openPanelForShape(selected);
	  redraw();
	  //return;
	  break;
	}
  }
  
  if (!selected) return;
  //if (!hit) return;
  
  startInlineEdit(selected);
  //startInlineEdit(hit);
  
  //selected = hit;
});

// when right-clicking the canvas then close editor
canvas.addEventListener("contextmenu", (e) => {
    if (editingShape) {
        e.preventDefault();   // prevent default context menu
        finishInlineEdit();
    }
});

/* -------------------- Toolbar text controls binding -------------------- */

// Panel text bindings
panelText.addEventListener('input', () => {
  if (selected) { 
    selected.text = panelText.value;
	redraw();
  }
});

panelTextSize.addEventListener('input', () => {
  if (selected) {
    selected.textSize = +panelTextSize.value;
	redraw();
  }
});

panelTextColor.addEventListener('input', () => {
  if (selected) {
    selected.textColor = panelTextColor.value;
	redraw();
  }
});

// save changes when user leaves input or presses Enter
textEditor.addEventListener("blur", finishInlineEdit);

textEditor.addEventListener("input", () => {
    autoResizeTextEditor();
});

// deselect when clicking outside panel will already close because canvas handles it
// close panel on Esc
document.addEventListener('keydown', (ev) => {

	// when right-clicking outside the canvas, close editor
	document.addEventListener("contextmenu", (e) => {
		if (!editingShape) return;

		// clicked inside the text editor ‚Üí keep editing
		if (textEditor.contains(e.target)) return;

		// clicked on canvas ‚Üí canvas handler above handles it
		if (e.target === canvas) return;

		// otherwise right-click outside ‚Üí close editor
		e.preventDefault();
		finishInlineEdit();
	});

	// Save changes when user leaves input or presses Enter
	if (ev.key === 'Escape') { 
		closePanel();
		selected = null;
		redraw(); 
	}
});

/* -------------------- Drawing Helpers -------------------- */
// start text editing inside the shape
function startInlineEdit(shape) {

    editingShape = shape;

    textEditor.value = shape.text || "";

	// remove old text behind of editing
	shape.text = "";
	redraw();
	
	//textEditor.style.textAlign = "center";
	textEditor.style.background = "transparent";
	textEditor.style.border = "none";        // optional
	textEditor.style.outline = "none";       // optional
	
	// NOT wrap, shape text can be longer than box
    textEditor.style.width = shape.w + "px";
    textEditor.style.height = shape.h + "px";

	debugger;
	const { cx, cy } = getCenter(shape);
	console.log("Center:", cx, cy);
	console.log("shape.x", shape.x);
	console.log("shape.y", shape.y);
	
	//textEditor.style.left = (shape.x) - 10 + "px";
    //textEditor.style.top = (shape.y) - 10 + "px";
	
	//textEditor.style.left = (shape.x - cx*0.0262) + "px";
    //textEditor.style.top = (shape.y + cy*0.0425) + "px";
    
	textEditor.style.left = (shape.x + canvas.offsetLeft) + "px";
    textEditor.style.top = (shape.y + canvas.offsetTop) + "px";
	console.log("width", shape.w);
	console.log("height", shape.h);
	
    // disable wrapping
    textEditor.style.whiteSpace = "nowrap";
    textEditor.style.overflow = "hidden";
	
	// center text
    //textEditor.style.textAlign = "center";
    //centerEditorText(shape);
	
    textEditor.style.display = "block";
    textEditor.focus();
    textEditor.select();
}

// get center of any shape
function getCenter(shape) {
    if (shape.type === "rectangle") {
        return {
            cx: shape.x + shape.w / 2,
            cy: shape.y + shape.h / 2
        };
    } else { 
        // circle ‚Äî your shape.x and shape.y ARE already the center
        return {
            cx: this.x + this.w / 2,
			cy: this.y + this.h / 2
			//cx: shape.x,
            //cy: shape.y
        };
    }
}

// rounded rect drawing
function drawRoundedOrPlainRect(ctx, x, y, w, h, radius) {
  const absW = Math.abs(w), absH = Math.abs(h);
  const r = Math.max(0, Math.min(radius || 0, Math.min(absW, absH) / 2));
  const x0 = w >= 0 ? x : x + w;
  const y0 = h >= 0 ? y : y + h;
  const W = absW, H = absH;

  if (!r) {
    ctx.beginPath();
    ctx.rect(x0, y0, W, H);
    //ctx.fill();
    //ctx.stroke();
    return;
  }

  ctx.beginPath();
  ctx.moveTo(x0 + r, y0);
  ctx.lineTo(x0 + W - r, y0);
  ctx.arcTo(x0 + W, y0, x0 + W, y0 + r, r);
  ctx.lineTo(x0 + W, y0 + H - r);
  ctx.arcTo(x0 + W, y0 + H, x0 + W - r, y0 + H, r);
  ctx.lineTo(x0 + r, y0 + H);
  ctx.arcTo(x0, y0 + H, x0, y0 + H - r, r);
  ctx.lineTo(x0, y0 + r);
  ctx.arcTo(x0, y0, x0 + r, y0, r);
  ctx.closePath();
  //ctx.fill();
  //ctx.stroke();
}

// grid: light dots every 10px, stronger dots every 50px
function drawGrid(ctx, step = 10) {
  const width = canvas.width;
  const height = canvas.height;

  ctx.save();
  ctx.beginPath();

  // small dots every 10px
  ctx.fillStyle = "#e2e2e2";

  for (let x = 0; x < width; x += step) {
    for (let y = 0; y < height; y += step) {
      ctx.fillRect(x, y, 1, 1);
    }
  }

  // stronger dots every 50px
  ctx.fillStyle = "#c9c9c9";
  for (let x = 0; x < width; x += 50) {
    for (let y = 0; y < height; y += 50) {
      ctx.fillRect(x, y, 1.7, 1.7);
    }
  }

  ctx.restore();
}

// snap-tp-grid
function snapToGrid(value, step = 10) {
  return Math.round(value / step) * step;
}

/*
clears the canvas and draw:
  1. All shapes
  2. Text inside shapes
  3. The temp shape (if drawing)
*/
function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // draw grid behind everything
  if (showGrid)
    drawGrid(ctx);
  // draw shapes
  shapes.forEach(s => {
    s.drawCenterPixel(ctx);
	s.draw(ctx, s === selected);
	renderText(ctx, s);
  });
  
  // draw temp shape (preview)
  if (tempShape) tempShape.draw(ctx, false);
}

// coordinate transforms
function screenToCanvas(e) {
  const r = canvas.getBoundingClientRect();
  return { 
    x: e.clientX - r.left,
	y: e.clientY - r.top
  };
}

function screenToWorld(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const cx = clientX - rect.left;
  const cy = clientY - rect.top;
  return { 
    x: (cx - offsetX) / scale,
	y: (cy - offsetY) / scale
  };
}

/*
Resizing Shapes: uses 4 corners handles:
	tl = top-left
	tr = top-right
	bl = bottom-left
	br = bottom-right
*/
function resizeShape(shape, handle, mx, my) {

  // snap-to-grid
  if (showGrid) {
    mx = snapToGrid(mx);
    my = snapToGrid(my);
  }
  
  // for rectangle
  if (shape.type === 'rectangle') {
    let x = shape.x, y = shape.y, w = shape.w, h = shape.h;
    const right = x + w;
    const bottom = y + h;

    if (handle === 'tl') {
      x = mx; y = my;
      w = right - mx;
      h = bottom - my;
    } else if (handle === 'tr') {
      y = my;
      w = mx - x;
      h = bottom - my;
    } else if (handle === 'bl') {
      x = mx;
      w = right - mx;
      h = my - y;
    } else if (handle === 'br') {
      w = mx - x;
      h = my - y;
    }

    if (w < 0) { x = x + w; w = Math.abs(w); }
    if (h < 0) { y = y + h; h = Math.abs(h); }

    shape.x = x; shape.y = y; shape.w = w; shape.h = h;

    if (shape.rounded) {
      shape.radius = Math.max(0, Math.min(shape.w, shape.h) * 0.1);
    }
  } else { // for circle
    const dx = mx - shape.x;
    const dy = my - shape.y;
    const r = Math.max(2, Math.sqrt(dx*dx + dy*dy));
    shape.w = r;
	shape.h = r;
  }
}

// saves the text before the textarea width resets
function finishInlineEdit() {
	debugger;
	console.log("finishInlineEdit")
    if (!editingShape) return;
	
    // save exactly the text the user wrote (NO wrapping)
    editingShape.text = textEditor.value;

	// hide editor
	textEditor.style.display = "none";
    editingShape = null;
	
	// redraw canvas with properly wrapped text
    redraw();
}

// adjusts height and wigth
function autoResizeTextEditor() {
	textEditor.style.width = editingShape.w + "px"; // keep width locked
    textEditor.style.height = "auto"; // reset
    textEditor.style.height = (textEditor.scrollHeight) + "px"; // fit to content
}

/*
wraps text so it fits inside the shape width
all text handling + wrapping + alignment

Draws the text according to:
	Position (center, top, bottom, left, right)
	Color
	Font size
	Alignment inside the shape
*/
function renderText(ctx, shape) {
    if (!shape.text) return;

    const padding = 6;
    const lineHeight = 16;
	
    ctx.save();
    ctx.fillStyle = shape.textColor || "#000";
    ctx.font = `${shape.textSize || 16}px sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // split text into lines (no wrapping)
    const lines = shape.text.split("\n");
	
    let x = shape.x + shape.w / 2;
    let y = shape.y + shape.h / 2;

    switch (shape.textPosition) {
        case "top":
            //x = shape.x;
            y = shape.y - lineHeight * (lines.length) - padding;
            break;
        case "bottom":
            //x = shape.x;
            y = shape.y + shape.h + lineHeight + padding;
            break;
        case "left":
		    ctx.textAlign = "right"; // text ends at the border
			x = shape.x - padding;   // just outside the left border
            //x = shape.x - shape.w;
            //y = shape.y + lineHeight;
            break;
        case "right":
		    ctx.textAlign = "left";                 // text starts at the border
			x = shape.x + shape.w + padding;        // just outside the right border
            //x = shape.x + shape.w + padding+6;
            //y = shape.y + lineHeight;
            break;
        default:
            // center (default)
            break;
    }

    // draw all lines
    for (let line of lines) {
        ctx.fillText(line, x, y);
        y += lineHeight;
    }
	
    //ctx.fillText(shape.text, x, y);
    ctx.restore();
}

function updateShapePropertiesPanel(shape) {
    if (!shape) return;

    document.getElementById("shapeFill").value = shape.opts.fill;
    document.getElementById("shapeBorder").value = shape.opts.border;
    document.getElementById("shapeOpacity").value = shape.opts.opacity * 100;
    document.getElementById("textSize").value = shape.textSize;
    document.getElementById("textColor").value = shape.textColor;

    // sync text position dropdown
    document.getElementById("textPosition").value = shape.textPosition;
}

function centerEditorText(shape) {
    const approxOffset = (shape.h / 2) - 10;
    textEditor.style.paddingTop = approxOffset + "px";
}

// draw arrow/edge
function drawArrow(from, to) {
    const startX = from.x + from.w / 2;
    const startY = from.y + from.h / 2;
    const endX = to.x + to.w / 2;
    const endY = to.y + to.h / 2;

    const headLength = 12;
    const angle = Math.atan2(endY - startY, endX - startX);

    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);

    // arrowhead
    ctx.lineTo(
        endX - headLength * Math.cos(angle - Math.PI / 6),
        endY - headLength * Math.sin(angle - Math.PI / 6)
    );
    ctx.moveTo(endX, endY);
    ctx.lineTo(
        endX - headLength * Math.cos(angle + Math.PI / 6),
        endY - headLength * Math.sin(angle + Math.PI / 6)
    );

    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;
    ctx.stroke();
}

</script>
</body>
</html>
